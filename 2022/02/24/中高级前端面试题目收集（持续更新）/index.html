<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>中高级前端面试题目收集（持续更新） | 稍纵即逝</title>
  <meta name="keywords" content=" 面试 ">
  <meta name="description" content="中高级前端面试题目收集（持续更新） | 稍纵即逝">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="https://coo2.top/404.html">
<meta property="og:site_name" content="稍纵即逝">
<meta property="og:locale" content="cn">
<meta property="article:published_time" content="2020-04-07T08:01:07.000Z">
<meta property="article:modified_time" content="2022-02-24T05:53:18.408Z">
<meta property="article:author" content="tanjiajian">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/tjj.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/tjj.jpg"/>
</a>
<div class="author">
    <span>tanjiajian</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/adam-tan"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1249118795@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1249118795&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(14)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="前端">
                        
                        前端
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="规范">
                        
                        规范
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="面试">
                        
                        面试
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="14">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Typescript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>模块化</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="All 面试 "
           href="/2022/02/24/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="中高级前端面试题目收集（持续更新）">中高级前端面试题目收集（持续更新）</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 前端 "
           href="/2022/02/24/AMD%E3%80%81CMD%E3%80%81CommonJS%E4%BB%A5%E5%8F%8AUMD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"
           data-tag="模块化"
           data-author="" >
            <span class="post-title" title="AMD、CMD、CommonJS以及UMD的简单对比">AMD、CMD、CommonJS以及UMD的简单对比</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 规范 "
           href="/2022/02/24/API%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API规范参考">API规范参考</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All "
           href="/2022/02/24/hexo%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All "
           href="/2022/02/24/hexo%E8%87%AA%E5%8A%A8%20%E9%83%A8%E7%BD%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="hexo自动 部署">hexo自动 部署</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 前端 "
           href="/2022/02/24/js%20%E5%B8%83%E5%B0%94%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%A4%E6%96%AD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="js 布尔值转换和数据类型的简单判断">js 布尔值转换和数据类型的简单判断</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 算法 "
           href="/2022/02/24/js%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="js常用算法面试题收集（持续更新）">js常用算法面试题收集（持续更新）</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 规范 "
           href="/2022/02/24/typescript/"
           data-tag="Typescript"
           data-author="" >
            <span class="post-title" title="typescript">typescript</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 算法 "
           href="/2022/02/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86js%E5%AE%9E%E7%8E%B0/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="二叉树深度优先遍历js实现">二叉树深度优先遍历js实现</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 规范 "
           href="/2022/02/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前端项目注释规范参考">前端项目注释规范参考</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All 面试 "
           href="/2022/02/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="移动端面试复习">移动端面试复习</span>
            <span class="post-date" title="2022-02-24 13:53:18">2022/02/24</span>
        </a>
        
        <a  class="All "
           href="/2021/05/20/2021%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2021面试总结">2021面试总结</span>
            <span class="post-date" title="2021-05-20 22:00:47">2021/05/20</span>
        </a>
        
        <a  class="All 面试 "
           href="/2020/04/07/2020%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="2020面试总结">2020面试总结</span>
            <span class="post-date" title="2020-04-07 10:17:50">2020/04/07</span>
        </a>
        
        <a  class="All 规范 "
           href="/2018/12/24/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%B5%8B%E6%B5%81%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前端自测流程">前端自测流程</span>
            <span class="post-date" title="2018-12-24 17:48:00">2018/12/24</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-中高级前端面试题目收集（持续更新）" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">中高级前端面试题目收集（持续更新）</h1>
    
    <div class="article-meta">
        
        <span class="top"><a>置顶</a></span>
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="面试">面试</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">面试</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-02-24 13:53:18'>2022-02-24 13:53</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#知识树"><span class="toc-text">知识树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css可以继承的属性"><span class="toc-text">css可以继承的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链的相关知识"><span class="toc-text">原型链的相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie"><span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node事件驱动模型"><span class="toc-text">node事件驱动模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clientWidth和offsetWidth宽度"><span class="toc-text">clientWidth和offsetWidth宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程和进程的差别"><span class="toc-text">线程和进程的差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络安全"><span class="toc-text">网络安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2和http1的区别"><span class="toc-text">http2和http1的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟dom的原理"><span class="toc-text">虚拟dom的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果要实现一个组件的动态加载，会用webpack的什么方法"><span class="toc-text">如果要实现一个组件的动态加载，会用webpack的什么方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件库遇到的难点问题"><span class="toc-text">组件库遇到的难点问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax实现"><span class="toc-text">ajax实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏任务微任务"><span class="toc-text">宏任务微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是reflow和repaint"><span class="toc-text">什么是reflow和repaint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new做了什么"><span class="toc-text">new做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄露"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-2-0对于http-1-x有哪些优点？"><span class="toc-text">http 2.0对于http 1.x有哪些优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtualDOM是什么"><span class="toc-text">virtualDOM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack性能优化汇总"><span class="toc-text">webpack性能优化汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件设计原则"><span class="toc-text">组件设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node中间件的原理"><span class="toc-text">node中间件的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http请求方式"><span class="toc-text">http请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-javascript-中的-this"><span class="toc-text">关于 javascript 中的 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简述-HTTPS-的工作原理，如何实现的加密传输"><span class="toc-text">简述 HTTPS 的工作原理，如何实现的加密传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍一下-import-和-require-有什么区别"><span class="toc-text">介绍一下 import 和 require 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是事件捕获机制，DOM0和DOM2"><span class="toc-text">什么是事件捕获机制，DOM0和DOM2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解变量提升"><span class="toc-text">理解变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端模块化：CommonJS-AMD-CMD-ES6"><span class="toc-text">前端模块化：CommonJS,AMD,CMD,ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承的几种方式"><span class="toc-text">继承的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象的几种方式"><span class="toc-text">创建对象的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue组件通信的方式"><span class="toc-text">vue组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端常用的设计模式"><span class="toc-text">前端常用的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js设计模式"><span class="toc-text">js设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amqp"><span class="toc-text">amqp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高性能建站指南"><span class="toc-text">高性能建站指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#块级格式化上下文"><span class="toc-text">块级格式化上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-百分比参照问题"><span class="toc-text">CSS 百分比参照问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-组件的生命周期方法"><span class="toc-text">React 组件的生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-的-Event-Loop-6个阶段"><span class="toc-text">Node 的 Event Loop: 6个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器与Node的事件循环-Event-Loop-有何区别"><span class="toc-text">浏览器与Node的事件循环(Event Loop)有何区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5移动端兼容问题"><span class="toc-text">H5移动端兼容问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步加载JS的方式有哪些？"><span class="toc-text">异步加载JS的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断js数据类型的方法"><span class="toc-text">判断js数据类型的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy和defineProperty"><span class="toc-text">Proxy和defineProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域提升"><span class="toc-text">作用域提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面性能指标"><span class="toc-text">页面性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染树的形成原理"><span class="toc-text">渲染树的形成原理</span></a>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>这里进行了一些常用面试题目的搜集，可供面试前参考，先罗列一遍，后期打算再进行分类整理</p>
</blockquote>
<h3 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h3><p>之前每次面试前，看一篇自己的总结面试题，感觉很好，但是每次这样效果太低下，一个个题目看，然后再进行回想，每个题目在你脑中渐渐形成一个孤立的荒岛，为了加快效率，希望大家<strong>构建自己的知识体系</strong></p>
<p>接下来，我自己罗列下前端知识体系，每次面试前根据知识体系回想回想一遍，把知识联系起来，形成一棵树，然后再用具体题目去充实上面的每个子树吧</p>
<ul>
<li>浏览器相关 （加载过程、三级缓存、浏览器缓存、垃圾回收）</li>
<li>网络 （tcp三次握手四次挥手、http、https握手过程、网络五层协议、XSS/CSRF/sql注入等网络安全问题）</li>
<li>js （类型判断、原型链、this指向、异步函数、继承、设计模式、设计原则、es6）</li>
<li>css （BFC、清除浮动、居中、css3实现三角形、主题切换方案）</li>
<li>html （语义化、canvas、空标签有哪些）</li>
<li>node.js （express、koa洋葱模型、eventEmitter的实现、事件循环、微任务与宏任务、async awiat、错误处理、pm2的使用、docker的使用）</li>
<li>Vue （<a href="https://juejin.cn/post/6844903479044112391" target="_blank" rel="noopener">双向绑定的原理</a>、v-model的原理、vue-router的实现、vuex的实现、vue3.0的新特性）</li>
<li>React （vue和react的区别、react的函数式组件、immutable、redux实现、React16的新特性、hook的使用、生命周期）</li>
<li>前端性能优化 （方案、性能监控）</li>
<li>webpack （配置、各种loader、原理、性能优化：多线程打包、代码分割、按需加载）</li>
<li>基础算法 （排序、链表、数、队列、栈）</li>
<li>git （命令、cli、rebase用法）</li>
<li>服务器 (服务端渲染、ssr)</li>
<li>客户端 ：RN/Weex、原生bridge</li>
<li>移动端（微信公众号开发、小程序、移动端问题：1px问题、点击穿透、图片懒加载）</li>
</ul>
<h2 id="css可以继承的属性"><a href="#css可以继承的属性" class="headerlink" title="css可以继承的属性"></a>css可以继承的属性</h2><ul>
<li><p>常用的css可继承的属性：</p>
<p>font：组合字体</p>
<p>font-family：规定元素的字体系列</p>
<p>font-weight：设置字体的粗细</p>
<p>font-size：设置字体的尺寸</p>
<p>font-style：定义字体的风格</p>
<p>text-indent：文本缩进</p>
<p>text-align：文本水平对齐</p>
<p>line-height：行高</p>
<p>color：文本颜色</p>
<p>visibility：元素可见性</p>
<p>光标属性：cursor</p>
</li>
<li><p>所有元素可以继承的</p>
<p>1、属性：cursor</p>
</li>
</ul>
<p>2、光标属性：cursor</p>
<ul>
<li><p>内联元素可以继承的属性</p>
<p>1、text-indent、text-align之外的文本系列属性</p>
</li>
</ul>
<p>3、除text-indent、text-align之外的文本系列属性</p>
<ul>
<li><p>块级元素可以继承的属性</p>
<p>text-indent、text-align</p>
</li>
</ul>
<h2 id="原型链的相关知识"><a href="#原型链的相关知识" class="headerlink" title="原型链的相关知识"></a>原型链的相关知识</h2><ul>
<li><strong>proto</strong>指向该对象的构造函数的原型对象。</li>
<li><strong>prototype</strong>指向该方法的原型对象，<strong>Object.prototype</strong>只是一个普通对象(普通对象没有prototype属性，所以值是undefined)，它是js原型链的最顶端,它的<code>__proto__</code>是null(有<code>__proto__</code>属性，但值是null，因为这是原型链的最顶端)。</li>
</ul>
<pre><code class="js">  Object.prototype.__proto__=== null;//true
  Object.prototype.prototype === undefied;//true</code></pre>
<ul>
<li>在js中如果A对象是由B函数构造的，那么<code>A.__proto__ === B.prototype</code>。javascript中对象是由Object创建的，函数是由Function创建的。</li>
<li><strong>内置的Object</strong>其实是一个函数对象，它是由Function创建的。<code>Object.__proto__ === Function.prototype;</code></li>
<li><strong>内置的Function</strong>也是一个函数对象，它是通过自己来创建自己的。<code>Function.__proto__=== Function.prototype;//true</code></li>
<li>js中<strong>每一个对象或函数</strong>都有<code>__proto__</code>属性，但是只有<strong>函数对象</strong>才有<strong>prototype</strong>属性。</li>
</ul>
<pre><code class="js">    // 函数对象
    function Person() {}
  // 普通对象
  var obj = {};

  obj.__proto__ === Object.prototype;//true

    obj.prototype === undefined;//true

    Person.__proto__ === Function.prototype;//true

    Person.prototype !== undefined;//true</code></pre>
<ul>
<li><p>原型链是基于<code>__proto__</code>形成的，继承是通过prototype实现的。</p>
</li>
<li><p>所有函数都有prototype属性，除了Function.prototype外，它是函数对象，但是没有prototype属性。<code>Function.prototype.prototype === undefined;//true</code></p>
</li>
<li><p>函数也是对象，因为<code>Function.prototype.__proto__</code>指向Object.prototype。</p>
</li>
</ul>
<pre><code class="js">    typeof Function.prototype.__proto__) === &quot;object&quot;;//true
    Function.prototype.__proto__=== Object.prototype;//true</code></pre>
<ul>
<li><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链(构造函数是不是对象new)</li>
<li><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbszdheq1j310o0lgabp.jpg" alt="img"></li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li>什么是cookie</li>
</ol>
<p>cookie是由服务器生成并保存在客户端的小型文本文件，它的优点是：</p>
<ul>
<li>高扩展性和可用性，比如,可以通过良好的编程控制存储在cookie的信息大小</li>
<li>数据持久性，cookie可以长期保存在浏览器中</li>
<li>一定的安全性，可以设置失效时间，通过加密技术和安全传送技术，防止信息被恶意串改</li>
</ul>
<p>缺点：</p>
<ul>
<li>cookie的长度和同一域名下的数量都有限制，长度不超过4k，数量firefox限制40，chrome没有限制</li>
<li>潜在的安全风险，cookie有可能被攻击者串改，或者被拦截</li>
<li>不适合保存状态，如一些防止表单重复提交的计时器</li>
<li>冗余，服务器不需要的信息也可能随cookie发送</li>
</ul>
<ol start="2">
<li>与session的区别</li>
</ol>
<p>session：服务端执行session机制时候会生成session的id值，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie(Session不一定必须依赖Cookie，也可以在url上)</p>
<h2 id="node事件驱动模型"><a href="#node事件驱动模型" class="headerlink" title="node事件驱动模型"></a>node事件驱动模型</h2><p>关于线程： 除了你的代码是单线程，其余都是多线程（线程池），nodejs本身是事件驱动，一个io事件完成会被放到一个事件队列中，主线程负责轮询这个队列，然后执行相应的回调函数。</p>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26" target="_blank" rel="noopener">参考1</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html" target="_blank" rel="noopener">参考2</a></p>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node.js 事件循环，定时器和 process.nextTick()</a> by node.js</p>
<h2 id="clientWidth和offsetWidth宽度"><a href="#clientWidth和offsetWidth宽度" class="headerlink" title="clientWidth和offsetWidth宽度"></a>clientWidth和offsetWidth宽度</h2><p>ele.clientWidth = 宽度 + padding</p>
<p>ele.offsetWidth = 宽度 + padding + border</p>
<p> ele.scrollTop = 被卷去的上侧距离</p>
<p> ele.scrollHeight = 自身实际的高度，可见部分加上不可见部分（不包括边框）</p>
<p>ele.offsetTop = 当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" target="_blank" rel="noopener"><code>offsetParent</code></a> 元素的顶部内边距的距离</p>
<p>Ps：懒加载是利用图片的ele.offsetTop和父元素的scrollTop的差判断图片是否在屏幕范围内</p>
<h2 id="线程和进程的差别"><a href="#线程和进程的差别" class="headerlink" title="线程和进程的差别"></a>线程和进程的差别</h2><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p><strong>常见Web漏洞及其防范</strong></p>
<ul>
<li>1.XSS(Cross Site Scripting)跨站脚本攻击<ul>
<li>攻击方式：利用html的漏洞，让网页执行不存在的js代码，比如在评论里写进代码，用户浏览到当条评论就会执行此段代码</li>
<li>防范：客户端与服务端同时做htmlEncode和jsEncode。服务端保障安全，客户端提升体验。服务端可使用XSS Filter实现，nodejs可使用XSS相关中间件。</li>
</ul>
</li>
<li>2.CSRF（Cross-site request forgery）跨站请求伪造<ul>
<li>方式：伪装成用户发请求，如劫持用户cookie获取请求，伪装成用户进行银行卡转账</li>
<li>防范：通过HTTP的Referer字段验证请求是否来自信任网站</li>
</ul>
</li>
<li>3.SQL注入<br>防范：SQL预编译</li>
<li>4.弱口令<br>防范：使用规则限制用户使用弱口令</li>
<li>5.非加密传输<br>防范：使用HTTPS(HTTPS原理：非对称加密交换密钥+对称加密数据+CA认证)</li>
<li>6.CFS(Cross Frame Script跨框架脚本攻击)与Clickjacking(点击劫持)<br>防范：服务端header设置X-Frame-Options为SAMEORIGIN</li>
</ul>
<h2 id="http2和http1的区别"><a href="#http2和http1的区别" class="headerlink" title="http2和http1的区别"></a>http2和http1的区别</h2><h2 id="虚拟dom的原理"><a href="#虚拟dom的原理" class="headerlink" title="虚拟dom的原理"></a>虚拟dom的原理</h2><h2 id="如果要实现一个组件的动态加载，会用webpack的什么方法"><a href="#如果要实现一个组件的动态加载，会用webpack的什么方法" class="headerlink" title="如果要实现一个组件的动态加载，会用webpack的什么方法"></a>如果要实现一个组件的动态加载，会用webpack的什么方法</h2><h2 id="组件库遇到的难点问题"><a href="#组件库遇到的难点问题" class="headerlink" title="组件库遇到的难点问题"></a>组件库遇到的难点问题</h2><h2 id="ajax实现"><a href="#ajax实现" class="headerlink" title="ajax实现"></a>ajax实现</h2><h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><p>任务执行顺序： 同步任务、异步任务(顺序：微任务（promise，nextTick）、宏任务(setTimeout，setInterval、setImmediate))</p>
<p>参考：<a href="https://juejin.im/post/5b498d245188251b193d4059#heading-6]" target="_blank" rel="noopener">宏任务与微任务</a></p>
<h2 id="什么是reflow和repaint"><a href="#什么是reflow和repaint" class="headerlink" title="什么是reflow和repaint"></a>什么是reflow和repaint</h2><blockquote>
<p>repaint（重绘）：如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint。repaint 的速度明显快于 reflow</p>
<p>reflow（回流）：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。</p>
</blockquote>
<p>reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>下面情况会导致reflow发生</p>
<p>1：改变窗口大小</p>
<p>2：改变文字大小</p>
<p>3：内容的改变，如用户在输入框中敲字</p>
<p>4：激活伪类，如:hover</p>
<p>5：操作class属性</p>
<p>6：脚本操作DOM</p>
<p>7：计算offsetWidth和offsetHeight</p>
<p>8：设置style属性</p>
<p>相关扩展：<a href="https://www.zhihu.com/question/33629083" target="_blank" rel="noopener">在移动端使用transform: translate代替top left marg等做位移有好处么 ？</a></p>
<h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><p>新建一个对象，并把this指向这个对象，同时使该对象继承函数的原型</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><ol>
<li><p>意外的全局变量， 在JavaScript文件中添加<code>&#39;use strict&#39;</code>，开启严格模式</p>
</li>
<li><p>闭包</p>
<ol>
<li><p>注意: 闭包本身没有错,不会引起内存泄漏.而是使用错误导致.</p>
</li>
<li><p>如闭包return回来的函数没有被使用的话，就好造成内存泄露，还有一些其他场景</p>
</li>
<li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大</p>
</li>
<li><p>循环引用</p>
</li>
</ol>
<pre><code class="js">   function handle () {
       var element = document.getElementById(“testId”);
      // 闭包
       element.onclick = function (){
           alert(element.id)
       }
   }</code></pre>
<p>   闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</p>
<p>   Ps: 可以<a href="https://www.zhihu.com/question/31078912" target="_blank" rel="noopener">参考</a></p>
</li>
<li><p>被遗忘的定时器和回调函数 在定时器完成工作的时候，手动清除定时器</p>
</li>
<li><p>DOM引用，保留了DOM节点的引用,导致GC没有回收</p>
</li>
<li><p>遗忘的事件监听器，如在单页面应用，组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收，需要在组件销毁的时候移除相关的事件</p>
</li>
</ol>
<p>参考 <a href="https://segmentfault.com/a/1190000020231307#item-5-5" target="_blank" rel="noopener">内存泄露</a></p>
<h2 id="http-2-0对于http-1-x有哪些优点？"><a href="#http-2-0对于http-1-x有哪些优点？" class="headerlink" title="http 2.0对于http 1.x有哪些优点？"></a>http 2.0对于http 1.x有哪些优点？</h2><ol>
<li><p>多路复用，多个http请求复用一个连接</p>
<blockquote>
<p>HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br>多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中</p>
<ul>
<li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>单个连接上可以并行交错的请求和响应，之间互不干扰</li>
</ul>
</blockquote>
</li>
<li><p>二进制分帧，在应用层和传输层直接加了一个二进制分帧，把http请求的数据分割成更小的二进制帧，从而实现多个数据流复用同一个连接的目的，减轻了服务器的连接压力</p>
</li>
<li><p>首部压缩，采用了HPACH的新算法进行首部压缩，减轻报文体积</p>
</li>
<li><p>服务器推送，类似websocket</p>
</li>
</ol>
<p><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">参考</a></p>
<h2 id="virtualDOM是什么"><a href="#virtualDOM是什么" class="headerlink" title="virtualDOM是什么"></a>virtualDOM是什么</h2><p>virtualDOM是DOM节点树的一个映射</p>
<p>使用原因：真实dom依赖环境，操作开销大，节点渲染频繁</p>
<p>它的作用是，每次数据变化时，通过virtualDOM执行diff算法进行对比得到差异结果后，再一次性对DOM进行批量更新操作</p>
<p>diff算法不是传统意义上的通过深度优先遍历DFS算法算法，它做了以下几点改进：</p>
<ol>
<li><p>同层级的节点进行比较</p>
<p>在新旧节点树之间按层级进行diff得到差异，可以算法复杂度降低到O(n)</p>
</li>
<li><p>按类型进行diff</p>
<p>VirtualDOM只对相同类型的同一个节点进行diff，当新旧节点发生了类型的改变时，则并不进行子树的比较，直接创建新类型的VirtualDOM，替换旧节点</p>
<p>例如同类型的组件照常进行比较，不同类型的组件不进行比较直接替换节点</p>
</li>
<li><p>列表按key进行diff</p>
<p>在没有key值的列表diff中，只能通过按顺序进行每个元素的对比，更新，插入与删除</p>
<p>如果有key就能够快速识别新旧列表之间的变化内容</p>
</li>
</ol>
<p><a href="https://juejin.im/post/5d81eec56fb9a06add4e63ba" target="_blank" rel="noopener">参考</a></p>
<h2 id="webpack性能优化汇总"><a href="#webpack性能优化汇总" class="headerlink" title="webpack性能优化汇总"></a><a href="https://juejin.im/post/5dcc45136fb9a02b450c2818" target="_blank" rel="noopener">webpack性能优化汇总</a></h2><ol>
<li><p>减少打包时间</p>
<ol>
<li>优化loader配置</li>
<li>happyPack插件开启多线程打包</li>
</ol>
</li>
<li><p>减少打包后的体积</p>
<ol>
<li>使用CDN放置部分资源</li>
<li>UglifyJS代码压缩</li>
</ol>
</li>
<li><p>优化打包质量</p>
<ol>
<li>分割代码以按需加载</li>
</ol>
</li>
</ol>
<p><a href="https://juejin.im/post/5b652b036fb9a04fa01d616b#heading-16" target="_blank" rel="noopener">参考</a></p>
<h2 id="组件设计原则"><a href="#组件设计原则" class="headerlink" title="组件设计原则"></a>组件设计原则</h2><ol>
<li>低耦合高内聚，</li>
<li>分清业务组件和通用组件</li>
<li>健壮性，保证能在各种场合适用</li>
</ol>
<h2 id="node中间件的原理"><a href="#node中间件的原理" class="headerlink" title="node中间件的原理"></a>node中间件的原理</h2><p>一个请求发送到服务器后，它的生命周期是 先收到request（请求），然后服务端处理，处理完了以后发送response（响应）回去</p>
<p>app.use 加载用于处理http请求的middleware（中间件），当一个请求来的时候，会依次被这些 middlewares处理。</p>
<p>中间件其是一个函数，在响应发送之前对请求进行一些操作</p>
<p>这个函数有些不太一样，它还有一个next参数，而这个next也是一个函数，它表示函数数组中的下一个函数</p>
<p>express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组</p>
<p>ps：<a href="https://cloud.tencent.com/developer/article/1467268" target="_blank" rel="noopener">koa与express的中间件机制揭秘</a> by 挥刀北上</p>
<h2 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。</td>
</tr>
<tr>
<td>HEAD</td>
<td>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</td>
</tr>
<tr>
<td>POST</td>
<td>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。</td>
</tr>
<tr>
<td>TRACE</td>
<td>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</td>
</tr>
</tbody></table>
<p><a href="https://juejin.im/entry/5b004085f265da0b886daf7c" target="_blank" rel="noopener">参考</a></p>
<h2 id="关于-javascript-中的-this"><a href="#关于-javascript-中的-this" class="headerlink" title="关于 javascript 中的 this"></a>关于 javascript 中的 this</h2><p>javascript 中的 this 和 OO 语言（如：java、C#）的 this 有着比较大的差异。</p>
<ul>
<li>1 请说明下方代码片段中对于 this 的使用是否正确，不正确的话，问题在哪里，如何修改？</li>
<li>2 写些小的代码片段说明一下你理解的 this。</li>
</ul>
<pre><code class="javascript">class Handler {
  get (req, res) {
    const type = req.query.type
    this[type](req, res)
  }

  typeA (req, res) {
    res.send(&#39;hello a&#39;)
  }

  typeB (req, res) {
    res.send(&#39;hello b&#39;)
  }
}

const express = require(&#39;express&#39;)
const app = express()

const handler = new Handler()
app.use(&#39;/&#39;, handler.get)</code></pre>
<p>答：</p>
<ul>
<li>不正确，问题在执行<code>app.use(&#39;/&#39;, handler.get)</code> 时,改变了this的指向， 因为此时函数中的this是根据上下文指定的</li>
<li>修改方式:</li>
</ul>
<pre><code class="javascript">const handler = function (req, res) {
  const hand = new Handler()
  hand.get(req, res)
}

app.use(&#39;/&#39;, handler)
</code></pre>
<ul>
<li>代码片段：</li>
</ul>
<pre><code class="js">const fun = function() { console.log(this) }
fun() //指向全局

const obj = { objFun : fun }
obj.objFun() //指向obj

fun.call(obj) //指向obj

const person = function () { this.name = &#39;lili&#39; }
myName = new person()
console.log(myName.name) //&#39;lili&#39;

const func = () =&gt; { console.log(this) }
func() //指向全局
func.call(obj) //指向全局</code></pre>
<h2 id="简述-HTTPS-的工作原理，如何实现的加密传输"><a href="#简述-HTTPS-的工作原理，如何实现的加密传输" class="headerlink" title="简述 HTTPS 的工作原理，如何实现的加密传输"></a>简述 HTTPS 的工作原理，如何实现的加密传输</h2><p>答：</p>
<p>简单描述下，https的是对网页整体内容进行加密，从而防止第三方恶意利用网站的加密传输技术</p>
<p>一般用户请求https时：</p>
<ul>
<li>客户端，把支持的加密方法（非对称加密：RSC，ECC，对称加密：DES，RC）、协议版本，生成随机码(客户端随机码 )发送到服务器</li>
<li>服务端选择其中一种加密方式和服务端随机码发送到客户端</li>
<li>客户端验证证书否有效后，生成随机key，用公钥加密字符串(客户端随机码+服务端随机码+随机key )，发送到服务端</li>
<li>服务端生用私钥解码字符串(客户端随机码+服务端随机码+随机key )，然后使用其作为对称加密的密码加密网页，返回网页给客户端</li>
<li>客户端获取加密网页，使用字符串(客户端随机码+服务端随机码+随机key )对内容进行解码，得到正确数据并显示在浏览器上</li>
</ul>
<p>上述过程只是根据个人记忆理解的描述，跟具体的步骤可能有些出入</p>
<p>这里有几个问题想说明下：</p>
<ul>
<li>为什么不直接使用公钥加密网页？因为网页往往较大，用公钥加密一般比较费时，而对称加密效率高但安全性低，故此选择了非对称加密和对称加密结合的方式进行</li>
<li>为什么要加入随机key？随机key是最重要的钥匙，和客户端随机码、服务端随机码是明文传输不一样，它是唯一不会被中间人获取的key。</li>
</ul>
<h2 id="介绍一下-import-和-require-有什么区别"><a href="#介绍一下-import-和-require-有什么区别" class="headerlink" title="介绍一下 import 和 require 有什么区别"></a>介绍一下 import 和 require 有什么区别</h2><p>答：</p>
<p>import：es6的模块加载规范，可用于浏览器环境和node环境(需要babal)</p>
<p>require：commonJS的加载规范，主要用于node环境</p>
<h2 id="什么是事件捕获机制，DOM0和DOM2"><a href="#什么是事件捕获机制，DOM0和DOM2" class="headerlink" title="什么是事件捕获机制，DOM0和DOM2"></a>什么是事件捕获机制，DOM0和DOM2</h2><p>1、DOM0级事件</p>
<p>就是直接通过 onclick 等方式实现相应的事件</p>
<p>这说明 DOM0 级添加事件时，后面的事件会覆盖前面的事件，而 DOM2级则不会，多个事件都会执行；</p>
<p>另外，DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p>
<p>2、DOM1级事件</p>
<p>因为DOM 1一般只有设计规范没有具体实现,所以一般跳过</p>
<p>3、</p>
<p>DOM2级事件</p>
<p><strong>主流浏览器 DOM2 级事件是通过以下两个方法用于处理指定和删除事件处理程序的操作</strong></p>
<p><strong>只有**</strong>DOM2事件流包括三个阶段**：</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p>即是事件捕获机制</p>
<p><a href="https://www.cnblogs.com/Leophen/p/11405579.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="理解变量提升"><a href="#理解变量提升" class="headerlink" title="理解变量提升"></a>理解变量提升</h2><ol>
<li>变量函数都会提升</li>
<li>函数声明提升(包括function(){}里面也算函数声明)</li>
<li>变量声明提升，不会提升赋值</li>
</ol>
<p><a href="https://juejin.im/post/5d36b06af265da1ba84ad143#heading-3" target="_blank" rel="noopener">参考</a></p>
<h2 id="前端模块化：CommonJS-AMD-CMD-ES6"><a href="#前端模块化：CommonJS-AMD-CMD-ES6" class="headerlink" title="前端模块化：CommonJS,AMD,CMD,ES6"></a>前端模块化：CommonJS,AMD,CMD,ES6</h2><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">参考</a></p>
<h2 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h2><ol>
<li><p>原型链继承 缺点：引用类型值的原型属性会被所有实例共享</p>
<pre><code class="js">function Parent() {
    this.name = &#39;父亲&#39;; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // -- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
}
function Child(like) {
    this.like = like;
}
Child.prototype = new Parent() // 核心

let boy1 = new Child()
let boy2 = new Child()</code></pre>
<p>补充：实际上所有类型的属性都会被共享，只不过值类型的属性，在修改时会在对象上新建属性覆盖，而值类型通过一些不改变原始地址的方式修改值时，所有实例都会被修改，因为此时实例记录的都是同一个原始地址</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsqldzsj30s80jw0v2.jpg" alt="image-20200330115542949" style="zoom:50%;" />
</li>
<li><p>借用构造函数继承 缺点：父类的方法不能复用,每次都要新建一次方法</p>
<pre><code class="js">function Parent(name) {
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
     this.arr = [1]; // (该属性，强调私有)
    this.say = function() { // 实例引用属性 (该属性，强调复用，需要共享)
        console.log(&#39;hello&#39;)
    }
}
function Child(name,like) {
    Parent.call(this,name);  // 核心
    this.like = like;
}
let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;);
let boy2 = new Child(&#39;小明&#39;, &#39;orange &#39;);</code></pre>
</li>
<li><p>组合继承 缺点：两次调用构造方法</p>
<pre><code class="js">function Parent(name) {
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
}
function Child(name,like) {
    Parent.call(this,name) // 核心   第二次
    this.like = like;
}
Child.prototype = new Parent() // 核心   第一次

&lt;!--这里是修复构造函数指向的代码--&gt;

let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;)
let boy2 = new Child(&#39;小明&#39;,&#39;orange&#39;)</code></pre>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000015216289#item-2-5" target="_blank" rel="noopener">参考</a></p>
<h2 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h2><ol>
<li><p>Object对象函数和对象字面量</p>
</li>
<li><p>工厂模式</p>
<p>用函数创造一个对象</p>
<p>缺点：没有解决对象识别的问题？</p>
<pre><code class="js">function person(name) {
  let obj = new Object()
  obj.name = name
  obj.say = function(){
  alert(&#39;say&#39;)
 }
}
let person1 = preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>原型链模式</p>
<p>用类创造一个对象</p>
<p>缺点：共享了方法属性</p>
<pre><code class="js">function person() {
}
person.prototype.name = name
person.prototype.say = function(){
  alert(&#39;say&#39;)
}
let person1 = new preson()</code></pre>
</li>
<li><p>构造函数模式</p>
<p>用类创造一个对象</p>
<p>缺点：每次新建时方法都会被创建一次</p>
<pre><code class="js">function person(name) {
  this.name = name
  this.say = function(){
  alert(&#39;say&#39;)
 }
}
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>组合使用原型链模式和构造函数模式<br>用类创造一个对象</p>
<pre><code class="js">function person(name) {
  this.name = name
  this.say = function(){
  alert(&#39;say&#39;)
 }
}
person.prototype = {
  constructor: person,
  say: function(){
  alert(&#39;say&#39;)
 }
}
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
</ol>
<h2 id="vue组件通信的方式"><a href="#vue组件通信的方式" class="headerlink" title="vue组件通信的方式"></a>vue组件通信的方式</h2><ol>
<li><p>父组件向子组件</p>
<blockquote>
<p>props：从上往下传</p>
<p>$children：获取父组件额属性</p>
<p>Porvide/inject： 在父组件中通过 <code>provider</code> 来提供属性，然后在子组件中通过 inject 来注入变量，深层级应对</p>
</blockquote>
</li>
<li><p>子组件向父组件</p>
<blockquote>
<p><code>$emit</code>： 传入事件和参数，父组件用<code>$on</code>监听</p>
<p>$parent</p>
</blockquote>
</li>
<li><p>其他</p>
<blockquote>
<p>中央事件总线EventBus：通过新建一个 <code>Vue</code> 事件 <code>bus</code> 对象，然后通过 <code>bus.$emit</code> 触发事件，<code>bus.$on</code> 监听触发的事件</p>
<p>vuex</p>
</blockquote>
</li>
</ol>
<h2 id="前端常用的设计模式"><a href="#前端常用的设计模式" class="headerlink" title="前端常用的设计模式"></a>前端常用的设计模式</h2><ol>
<li><p>工厂模式</p>
<blockquote>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</p>
</blockquote>
<p>例子：父类就像工厂生产自行车，可能会有轮子、把手、踩踏板、刹车，但是不同型号的自行车会有不同的东西如变速器，这些交给子类生产线复制</p>
</li>
<li><p>单例模式</p>
<blockquote>
<p>一个单一的类，该类负责创建自己的对象，同时确保只有<strong>单个对象</strong>被创建，并提供一个访问它的全局访问点</p>
</blockquote>
<p>例子： 前端弹窗的实现，调用多次弹窗函数，只实例化一次弹窗</p>
</li>
<li><p>代理模式</p>
<blockquote>
<p>为其他对象提供一种代理层以控制对这个对象的访问，不直接访问对象</p>
</blockquote>
<p>例子：限制接口频繁访问访问数据库，可以做一层代理，一段时间</p>
</li>
<li><p>观察者模式</p>
<blockquote>
<p>存在一对多关系时，则使用观察者模式</p>
</blockquote>
<p>例子：vue的双向绑定，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p>vs：</p>
<p>发布/订阅模式</p>
<blockquote>
<p>之前是观察者模式的别名，现在有所区别，发布订阅模式相比观察者模式多了个事件通道作为调度中心</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmpgz17qoj30fe0acgp9.jpg" alt="img"></p>
</blockquote>
</li>
<li><p>状态模式</p>
<blockquote>
<p>关键是区分事物内部的状态，事物内部状态往往会带来事物的行为改变，即允许对象在内部状态发生改变时改变它的行为</p>
</blockquote>
</li>
<li><p>职责链模式</p>
<blockquote>
<p> 处理请求组成的一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象</p>
</blockquote>
</li>
<li><p>策略模式</p>
<blockquote>
<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</blockquote>
<p>例子：表单验证的实现，表单的各种校验函数封装成策略对象，通过外部参数组合使用表单校验</p>
</li>
<li><p>适配器模式</p>
<blockquote>
<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>
</blockquote>
</li>
</ol>
<p><a href="https://www.cnblogs.com/tugenhua0707/p/5198407.html" target="_blank" rel="noopener">Javascript设计模式详解</a></p>
<h2 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h2><ol>
<li><p>单一职责原则</p>
<blockquote>
<p>单一职责原则，一个类只提供一种功能，不要存在过多导致类变化的原因。</p>
</blockquote>
</li>
<li><p>开放封闭原则</p>
<blockquote>
<p>类，方法等应当对其扩展开放，对其修改封闭</p>
</blockquote>
</li>
<li><p>里氏替换原则</p>
<blockquote>
<p>子类必须能够替换它们的基类。</p>
</blockquote>
</li>
<li><p>依赖倒置原则</p>
<blockquote>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p>
</blockquote>
</li>
<li><p>接口分离原则</p>
<blockquote>
<p>使用多个专门的接口来取代一个统一的接口</p>
</blockquote>
</li>
<li><p>最少知识原则</p>
<blockquote>
<p>就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话</p>
</blockquote>
</li>
</ol>
<h2 id="amqp"><a href="#amqp" class="headerlink" title="amqp"></a><a href="https://juejin.im/post/5dfc93a5f265da339b500273" target="_blank" rel="noopener">amqp</a></h2><h2 id="高性能建站指南"><a href="#高性能建站指南" class="headerlink" title="高性能建站指南"></a>高性能建站指南</h2><ol>
<li>减少http请求 方式：合并css、js文件，使用精灵图</li>
<li>使用cdn加快加载速度</li>
<li>开启浏览器缓存</li>
<li>css放头部，减少白屏，防止其阻碍页面呈现，页面会等css加载完再呈现内容</li>
<li>js放底部，防止其阻塞资源并行加载，不能并行加载的原因是保证js的顺序</li>
<li>开启服务器gzip压缩</li>
</ol>
<h2 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与,</p>
<p>哪些情况会产生BFC:</p>
<ol>
<li><p>根元素</p>
</li>
<li><p>float属性不为none</p>
</li>
<li><p>position为absolute或fixed</p>
</li>
<li><p>display为inline-block, table-cell, table-caption, flex, inline-flex</p>
</li>
<li><p>overflow不为visible</p>
</li>
</ol>
<p>BFC 特性及应用：</p>
<ul>
<li>同一个 BFC 下外边距会发生重叠</li>
<li>计算高度时浮动的元素参与计算（清除浮动）</li>
<li>浮动元素不重叠</li>
<li>用来实现两列自适应布局</li>
</ul>
<h2 id="CSS-百分比参照问题"><a href="#CSS-百分比参照问题" class="headerlink" title="CSS 百分比参照问题"></a>CSS 百分比参照问题</h2><ul>
<li><p>参照父元素<strong>宽度</strong>的元素：padding <strong>margin</strong> width text-indent</p>
</li>
<li><p>参照父元素高度的元素：height</p>
</li>
<li><p>参照父元素属性:font-size line-height</p>
</li>
<li><p>特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度</p>
</li>
</ul>
<h2 id="React-组件的生命周期方法"><a href="#React-组件的生命周期方法" class="headerlink" title="React 组件的生命周期方法"></a>React 组件的生命周期方法</h2><p>一些最重要的生命周期方法是：</p>
<ol>
<li><strong><em>componentWillMount**</em></strong>()** – 在渲染之前执行，在客户端和服务器端都会执行。</li>
<li><strong><em>componentDidMount**</em></strong>()** – 仅在第一次渲染后在客户端执行。</li>
<li><strong><em>componentWillReceiveProps**</em></strong>()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</li>
<li><strong><em>shouldComponentUpdate**</em></strong>()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回<strong>true</strong> 否则返回 <strong>false</strong>。默认情况下，它返回 false。</li>
<li><strong><em>componentWillUpdate**</em></strong>()** – 在 DOM 中进行渲染之前调用。</li>
<li><strong><em>componentDidUpdate**</em></strong>()** – 在渲染发生后立即调用。</li>
<li><strong><em>componentWillUnmount**</em></strong>()** – 从 DOM 卸载组件后调用。用于清理内存空间。</li>
</ol>
<h2 id="Node-的-Event-Loop-6个阶段"><a href="#Node-的-Event-Loop-6个阶段" class="headerlink" title="Node 的 Event Loop: 6个阶段"></a>Node 的 Event Loop: 6个阶段</h2><ul>
<li><p>timer 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p>
</li>
<li><p>I/O 阶段: 执行上轮循环残流的<code>callback</code></p>
</li>
<li><p>idle, prepare</p>
</li>
<li><p>poll: 等待回调</p>
<ul>
<li><ol>
<li>执行回调</li>
</ol>
</li>
<li><ol>
<li>执行定时器</li>
</ol>
<ul>
<li>如有到期的<code>setTimeout / setInterval</code>， 则返回 timer 阶段</li>
<li>如有<code>setImmediate</code>，则前往 check 阶段</li>
</ul>
</li>
</ul>
</li>
<li><p>check</p>
<ul>
<li>执行<code>setImmediate</code></li>
</ul>
</li>
<li><p>close callbacks</p>
</li>
</ul>
<h2 id="浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="浏览器与Node的事件循环(Event Loop)有何区别"></a><a href="https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别</a></h2><p>node跟浏览器端相差比较大，timers 阶段有几个 setTimeout/setInterval 都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务</p>
<h2 id="H5移动端兼容问题"><a href="#H5移动端兼容问题" class="headerlink" title="H5移动端兼容问题"></a><a href="https://segmentfault.com/a/1190000015131445" target="_blank" rel="noopener">H5移动端兼容问题</a></h2><h2 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h2><ul>
<li>defer：浏览器解析完成后执行，defer之间保证执行顺序</li>
<li><code>async</code>：尽快执行，阻塞解析，不保证顺序</li>
<li>创建<code>script</code>，在onload后，插入到<code>DOM</code>中，加载完毕后<code>callBcak</code></li>
</ul>
<h2 id="判断js数据类型的方法"><a href="#判断js数据类型的方法" class="headerlink" title="判断js数据类型的方法"></a>判断js数据类型的方法</h2><ol>
<li><p>typeof</p>
<ul>
<li>对于基本类型，除 null 以外，均可以返回正确的结果。</li>
<li>除 function 以外，一律返回 object 类型。</li>
<li>对于 null ，返回 object 类型。</li>
<li>对于 function 返回  function 类型</li>
</ul>
</li>
<li><p>instanceof</p>
<ul>
<li><strong>instanceof 检测的是原型</strong></li>
<li><strong>instanceof 只能用来判断两个对象是否属于实例关系</strong> <strong>， 而不能判断一个对象实例具体属于哪种类型。</strong></li>
</ul>
</li>
<li><p>toString</p>
<p><code>Object.prototype.toString.call()</code></p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="Proxy和defineProperty"><a href="#Proxy和defineProperty" class="headerlink" title="Proxy和defineProperty"></a>Proxy和defineProperty</h2><ul>
<li><p><strong>Object.defineProperty</strong> ：该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象</p>
<pre><code class="js">var obj = {};
Object.defineProperty(obj, &quot;num&quot;, {
    value : 1,
    writable : true,
    enumerable : true,
    configurable : true
});
//  对象 obj 拥有属性 num，值为 1
</code></pre>
</li>
<li><p><strong>proxy</strong> ：控制和修改Object的基本行为, 比起defindProperty可以重定义更多的行为，除了 get 和 set 之外，proxy 可以拦截多达 13 种操作</p>
<pre><code class="js">var proxy = new Proxy(target, handler);
/* new Proxy()表示生成一个Proxy实例
target参数表示所要拦截的目标对象
handler参数也是一个对象，用来定制拦截行为。*/
</code></pre>
</li>
</ul>
<p>参考：<a href="https://juejin.im/post/5be4f7cfe51d453339084530#heading-4" target="_blank" rel="noopener">ES6 系列之 defineProperty 与 proxy</a></p>
<h2 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h2><ol>
<li><em>变量声明、函数声明都会被提升到作用域顶处；</em></li>
<li>当出现相同名称时，优先级为：<strong>变量声明(foo#1) &gt; 函数声明(foo#2) &gt; 变量赋值(foo#3)*</strong></li>
</ol>
<h2 id="页面性能指标"><a href="#页面性能指标" class="headerlink" title="页面性能指标"></a>页面性能指标</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsdka5bj31pc0n6ti1.jpg" alt="蚂蚁金服如何把前端性能监控做到极致?"></p>
<p>页面加载时长是被清晰的标在这个页面的底部的。它是指 DOM <code>load</code> 事件触发完成，它的优点有：</p>
<ul>
<li>原生 API；</li>
<li>接受度高；</li>
<li>感知明显（浏览器 Tab 停止 loading）。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>无法准确反映页面加载性能；</li>
<li>易受特殊情况影响。</li>
</ul>
<p>为了解决这个问题，W3C 的工作小组引入了首次渲染 / 首次内容渲染。首次渲染是指第⼀个非网页背景像素渲染，⾸次内容渲染是指第一个⽂本、图像、背景图片或非白色 canvas/SVG 渲染。</p>
<p>相关：</p>
<p><a href="https://www.cnblogs.com/xiaohuochai/p/9182710.html" target="_blank" rel="noopener">使用chrome开发者工具中的performance面板解决性能瓶颈</a></p>
<h2 id="渲染树的形成原理"><a href="#渲染树的形成原理" class="headerlink" title="渲染树的形成原理"></a><a href="https://juejin.im/post/5da2f4f7f265da5b8a516502#heading-7" target="_blank" rel="noopener">渲染树的形成原理</a></h2><blockquote>
<p>注意点:</p>
<ol>
<li>CSS解析可以与DOM解析同进行</li>
<li>如果只有 CSS 和 HTML 的页面，CSS 不会影响 DOM 树的创建，但是如果页面中还有 JavaScript，结论就不一样了。</li>
</ol>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1249118795@qq.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '82a6fcaf7cba18f76843',
            clientSecret: '26bace5e3f3042d51108e0ac7400afb6fe450660',
            repo: 'adam-tan.github.io',
            owner: 'adam-tan',
            admin: ['adam-tan'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10),
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 tanjiajian
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
