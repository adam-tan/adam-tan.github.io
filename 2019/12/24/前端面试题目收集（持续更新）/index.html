<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>稍纵即逝</title>
  <meta name="keywords" content=" 面试 ">
  <meta name="description" content="稍纵即逝">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="https://coo2.top/404.html">
<meta property="og:site_name" content="稍纵即逝">
<meta property="og:locale">
<meta property="article:published_time" content="2020-04-07T08:01:07.000Z">
<meta property="article:modified_time" content="2022-03-25T07:42:02.013Z">
<meta property="article:author" content="tanjiajian">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/tjj.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/tjj.jpg"/>
</a>
<div class="author">
    <span>tanjiajian</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/adam-tan"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1249118795@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1249118795&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(17)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="前端">
                        
                        前端
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="规范">
                        
                        规范
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="面试">
                        
                        面试
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="17">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Typescript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>模块化</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="All 面试 "
           href="/2019/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2019-12-24 15:48:00">2019/12/24</span>
        </a>
        
        <a  class="All "
           href="/2022/03/25/tree-shareking-%E6%98%AF%E4%BB%80%E4%B9%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tree-shareking 是什么">tree-shareking 是什么</span>
            <span class="post-date" title="2022-03-25 11:54:48">2022/03/25</span>
        </a>
        
        <a  class="All "
           href="/2022/03/20/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前端模块化">前端模块化</span>
            <span class="post-date" title="2022-03-20 16:37:03">2022/03/20</span>
        </a>
        
        <a  class="All "
           href="/2022/03/12/js%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="js错误处理">js错误处理</span>
            <span class="post-date" title="2022-03-12 15:02:52">2022/03/12</span>
        </a>
        
        <a  class="All "
           href="/2021/09/24/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3redux%E7%94%9F%E6%80%81%E5%BA%93%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2021-09-24 20:00:00">2021/09/24</span>
        </a>
        
        <a  class="All 面试 "
           href="/2021/09/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2021-09-17 20:00:00">2021/09/17</span>
        </a>
        
        <a  class="All 前端 "
           href="/2021/07/03/js%20%E5%B8%83%E5%B0%94%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%A4%E6%96%AD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2021-07-03 22:33:00">2021/07/03</span>
        </a>
        
        <a  class="All 算法 "
           href="/2021/03/04/%E6%80%8E%E6%A0%B7%E7%94%A8js%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%9F/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2021-03-04 18:34:00">2021/03/04</span>
        </a>
        
        <a  class="All "
           href="/2020/09/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="策略模式">策略模式</span>
            <span class="post-date" title="2020-09-24 20:00:00">2020/09/24</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/09/03/js%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-09-03 17:11:00">2020/09/03</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-08-15 20:00:00">2020/08/15</span>
        </a>
        
        <a  class="All 规范 "
           href="/2020/08/03/typescript/"
           data-tag="Typescript"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-08-03 12:13:00">2020/08/03</span>
        </a>
        
        <a  class="All 规范 "
           href="/2020/06/14/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-06-14 16:00:00">2020/06/14</span>
        </a>
        
        <a  class="All 规范 "
           href="/2020/04/03/API%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-04-03 22:33:00">2020/04/03</span>
        </a>
        
        <a  class="All "
           href="/2020/04/03/hexo%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-04-03 22:33:00">2020/04/03</span>
        </a>
        
        <a  class="All 前端 "
           href="/2020/03/02/AMD%E3%80%81CMD%E3%80%81CommonJS%E4%BB%A5%E5%8F%8AUMD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"
           data-tag="模块化"
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2020-03-02 21:03:00">2020/03/02</span>
        </a>
        
        <a  class="All 规范 "
           href="/2018/12/24/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%B5%8B%E6%B5%81%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2018-12-24 17:48:00">2018/12/24</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-前端面试题目收集（持续更新）" class="article article-type-post" itemscope itemprop="blogPost">
    
    <div class="article-meta">
        
        <span class="top"><a>置顶</a></span>
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="面试">面试</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">面试</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-03-25 15:42:02'>2019-12-24 15:48</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%A0%91"><span class="toc-text">知识树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">CSS可以继承的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%B1%85%E4%B8%AD"><span class="toc-text">CSS居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">原型链的相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie"><span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">node事件驱动模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-nextTick"><span class="toc-text">process.nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setImmediate-%E5%AF%B9%E6%AF%94-setTimeout"><span class="toc-text">setImmediate() 对比 setTimeout()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clientWidth%E5%92%8CoffsetWidth%E5%AE%BD%E5%BA%A6"><span class="toc-text">clientWidth和offsetWidth宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-text">线程和进程的差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">网络安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2%E5%92%8Chttp1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">http2和http1的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">虚拟dom的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BC%9A%E7%94%A8webpack%E7%9A%84%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95"><span class="toc-text">如果要实现一个组件的动态加载，会用webpack的什么方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E5%AE%9E%E7%8E%B0"><span class="toc-text">ajax实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">宏任务微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFreflow%E5%92%8Crepaint"><span class="toc-text">什么是reflow和repaint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">new做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">new的模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-2-0%E5%AF%B9%E4%BA%8Ehttp-1-x%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">http 2.0对于http 1.x有哪些优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtualDOM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">virtualDOM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB"><span class="toc-text">webpack性能优化汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">组件设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">node中间件的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">http请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-javascript-%E4%B8%AD%E7%9A%84-this"><span class="toc-text">关于 javascript 中的 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-HTTPS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93"><span class="toc-text">简述 HTTPS 的工作原理，如何实现的加密传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-import-%E5%92%8C-require-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">介绍一下 import 和 require 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%EF%BC%8CDOM0%E5%92%8CDOM2"><span class="toc-text">什么是事件捕获机制，DOM0和DOM2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">理解变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87"><span class="toc-text">作用域提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9ACommonJS-AMD-CMD-ES6"><span class="toc-text">前端模块化：CommonJS,AMD,CMD,ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">继承的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建对象的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">vue组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">前端常用的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">js设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amqp"><span class="toc-text">amqp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97"><span class="toc-text">高性能建站指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">块级格式化上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-%E7%99%BE%E5%88%86%E6%AF%94%E5%8F%82%E7%85%A7%E9%97%AE%E9%A2%98"><span class="toc-text">CSS 百分比参照问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">React 组件的生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-%E7%9A%84-Event-Loop-6%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">Node 的 Event Loop: 6个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8ENode%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-text">浏览器与Node的事件循环(Event Loop)有何区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="toc-text">H5移动端兼容问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">异步加载JS的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">判断js数据类型的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy%E5%92%8CdefineProperty"><span class="toc-text">Proxy和defineProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">页面性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-text">渲染树的形成原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all-%E5%92%8CPromise-race%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">Promise.all()和Promise.race模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-%E4%B8%AD-loader-%E5%92%8C-plugin-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">webpack 中 loader 和 plugin 的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">Vue 中的 computed 是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">css优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%AD%E7%9A%84-undefined-%EF%BC%9F-%E9%98%BF%E9%87%8C"><span class="toc-text">如何修复输出值中的 undefined ？(阿里)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">普通函数和箭头函数this的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-nextTick%E5%AE%9E%E7%8E%B0"><span class="toc-text">vue nextTick实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%AE%80%E8%BF%B0"><span class="toc-text">redux简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-hook"><span class="toc-text">react hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-text">webpack异步加载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%A4%A7%E9%87%8Fif%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">遇到大量if的代码如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F"><span class="toc-text">获取DOM元素大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-hook%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">react hook的优缺点</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%A0%91"><span class="toc-text">知识树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">CSS可以继承的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%B1%85%E4%B8%AD"><span class="toc-text">CSS居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">原型链的相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie"><span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">node事件驱动模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-nextTick"><span class="toc-text">process.nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setImmediate-%E5%AF%B9%E6%AF%94-setTimeout"><span class="toc-text">setImmediate() 对比 setTimeout()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clientWidth%E5%92%8CoffsetWidth%E5%AE%BD%E5%BA%A6"><span class="toc-text">clientWidth和offsetWidth宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-text">线程和进程的差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">网络安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2%E5%92%8Chttp1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">http2和http1的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">虚拟dom的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BC%9A%E7%94%A8webpack%E7%9A%84%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95"><span class="toc-text">如果要实现一个组件的动态加载，会用webpack的什么方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E5%AE%9E%E7%8E%B0"><span class="toc-text">ajax实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">宏任务微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFreflow%E5%92%8Crepaint"><span class="toc-text">什么是reflow和repaint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">new做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">new的模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-2-0%E5%AF%B9%E4%BA%8Ehttp-1-x%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">http 2.0对于http 1.x有哪些优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtualDOM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">virtualDOM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB"><span class="toc-text">webpack性能优化汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">组件设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">node中间件的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">http请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-javascript-%E4%B8%AD%E7%9A%84-this"><span class="toc-text">关于 javascript 中的 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-HTTPS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93"><span class="toc-text">简述 HTTPS 的工作原理，如何实现的加密传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-import-%E5%92%8C-require-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">介绍一下 import 和 require 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%EF%BC%8CDOM0%E5%92%8CDOM2"><span class="toc-text">什么是事件捕获机制，DOM0和DOM2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">理解变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87"><span class="toc-text">作用域提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9ACommonJS-AMD-CMD-ES6"><span class="toc-text">前端模块化：CommonJS,AMD,CMD,ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">继承的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建对象的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">vue组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">前端常用的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">js设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amqp"><span class="toc-text">amqp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97"><span class="toc-text">高性能建站指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">块级格式化上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-%E7%99%BE%E5%88%86%E6%AF%94%E5%8F%82%E7%85%A7%E9%97%AE%E9%A2%98"><span class="toc-text">CSS 百分比参照问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">React 组件的生命周期方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-%E7%9A%84-Event-Loop-6%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">Node 的 Event Loop: 6个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8ENode%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-text">浏览器与Node的事件循环(Event Loop)有何区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="toc-text">H5移动端兼容问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">异步加载JS的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">判断js数据类型的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy%E5%92%8CdefineProperty"><span class="toc-text">Proxy和defineProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">页面性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-text">渲染树的形成原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all-%E5%92%8CPromise-race%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">Promise.all()和Promise.race模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-%E4%B8%AD-loader-%E5%92%8C-plugin-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">webpack 中 loader 和 plugin 的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">Vue 中的 computed 是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">css优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%AD%E7%9A%84-undefined-%EF%BC%9F-%E9%98%BF%E9%87%8C"><span class="toc-text">如何修复输出值中的 undefined ？(阿里)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">普通函数和箭头函数this的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-nextTick%E5%AE%9E%E7%8E%B0"><span class="toc-text">vue nextTick实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%AE%80%E8%BF%B0"><span class="toc-text">redux简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-hook"><span class="toc-text">react hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-text">webpack异步加载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%A4%A7%E9%87%8Fif%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">遇到大量if的代码如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F"><span class="toc-text">获取DOM元素大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-hook%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">react hook的优缺点</span></a></li></ol></div></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>这里进行了一些常用面试题目的搜集，可供面试前参考，先罗列一遍，后期打算再进行分类整理</p>
<p>学习一个东西，需要带有目的、带有问题去学，不能为了学而学</p>
</blockquote>
<h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p>之前每次面试前，看一篇自己的总结面试题，感觉很好，但是每次这样效果太低下，一个个题目看，然后再进行回想，每个题目在你脑中渐渐形成一个孤立的荒岛，为了加快效率，希望大家<strong>构建自己的知识体系</strong></p>
<p>接下来，我自己罗列下前端知识体系，每次面试前根据知识体系回想回想一遍，把知识联系起来，形成一棵树，然后再用具体题目去充实上面的每个子树吧</p>
<ul>
<li>浏览器相关 （加载过程、三级缓存、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903764566999054#heading-11">浏览器缓存</a>、垃圾回收、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904016325902344#heading-13">v8垃圾回收</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903638238756878#heading-4">事件循环</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33058983">其他参考</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018935873">Ajax</a>、<a target="_blank" rel="noopener" href="http://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html">浏览器工作原理</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903593275817998#heading-3">缓存</a>）</li>
<li>网络 （tcp三次握手四次挥手、http、https握手过程、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22238021/article/details/80279001">网络五层协议</a>、XSS/CSRF/sql注入等网络安全问题）</li>
<li>js （类型判断、原型链、this指向、异步函数、继承、设计模式、设计原则、es6、<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/155">浮点数</a>）</li>
<li>css （BFC、清除浮动、居中、css3实现三角形、主题切换方案、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41604775">css选择器权重</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010780991">css3</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012739764">浮动</a>）</li>
<li>html （语义化、canvas、空标签有哪些）</li>
<li>node.js （express、koa<a target="_blank" rel="noopener" href="https://juejin.cn/post/6957258059022499854">洋葱模型</a>、eventEmitter的实现、事件循环、微任务与宏任务、async awiat、错误处理、pm2的使用、docker的使用）</li>
<li>Vue （双向绑定的原理 （<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903479044112391">1</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903869730799629#heading-10">2</a>）、v-model的原理、vue-router的实现、vuex的实现、vue3.0的新特性）</li>
<li>React （<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100228073#:~:text=%E8%80%8CVue%E6%98%AF%E9%80%9A%E8%BF%87%E4%B8%80,%E7%9A%84%EF%BC%8C%E6%9B%B4%E5%8A%A0%E7%BA%AF%E7%B2%B9%E6%9B%B4%E5%8A%A0%E5%8E%9F%E7%94%9F%E3%80%82">vue和react的区别</a>、vuex和redux的区别、react的函数式组件、immutable、redux实现、React16的新特性、hook的使用、生命周期）</li>
<li><a target="_blank" rel="noopener" href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/">前端性能优化</a> （方案、性能监控）</li>
<li>webpack （配置、各种loader、原理、性能优化：多线程打包、代码分割、按需加载）</li>
<li>基础算法 （排序、链表、数、队列、栈）</li>
<li>git （命令、cli、rebase用法）</li>
<li>服务器 (服务端渲染、ssr)</li>
<li>客户端 ：RN/Weex、原生bridge</li>
<li>移动端（微信公众号开发、小程序、移动端问题：1px问题、点击穿透、图片懒加载）</li>
</ul>
<p>资料：<a target="_blank" rel="noopener" href="https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd">字节飞书面试题</a></p>
<h2 id="CSS可以继承的属性"><a href="#CSS可以继承的属性" class="headerlink" title="CSS可以继承的属性"></a>CSS可以继承的属性</h2><ul>
<li><p>常用的css可继承的属性：</p>
<p>font：组合字体</p>
<p>font-family：规定元素的字体系列</p>
<p>font-weight：设置字体的粗细</p>
<p>font-size：设置字体的尺寸</p>
<p>font-style：定义字体的风格</p>
<p>text-indent：文本缩进</p>
<p>text-align：文本水平对齐</p>
<p>line-height：行高</p>
<p>color：文本颜色</p>
<p>visibility：元素可见性</p>
<p>光标属性：cursor</p>
</li>
<li><p>所有元素可以继承的属性：cursor</p>
</li>
<li><p>内联元素可以继承的属性：text-indent、text-align之外的文本系列属性</p>
</li>
<li><p>块级元素可以继承的属性：text-indent、text-align</p>
</li>
</ul>
<h2 id="CSS居中"><a href="#CSS居中" class="headerlink" title="CSS居中"></a>CSS居中</h2><ul>
<li>内联元素：<ul>
<li>水平：text-align</li>
<li>垂直：<ul>
<li>vertical-alight：middle；</li>
<li>line-height：元素高度 (只对inline中文字有效)</li>
</ul>
</li>
</ul>
</li>
<li>块级元素：<ul>
<li>margin：0 auto; （只能水平居中）</li>
<li>position<ul>
<li>定宽：position: absolute; left: 50%; right: 50%; margin-left:负自身宽度的一半; margin-top:负自身高度的一半;</li>
<li>不定宽：position: absolute; left: 50%;  left：50%; top:50%; transfrom:(-50%,-50%);</li>
</ul>
</li>
<li>flex：justify-content:center;  align-item: center;</li>
<li>table：diplay：table-cell;vertical-align: middle;</li>
</ul>
</li>
</ul>
<h2 id="原型链的相关知识"><a href="#原型链的相关知识" class="headerlink" title="原型链的相关知识"></a>原型链的相关知识</h2><p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220225-175614012.png" alt="图 1">  </p>
<ul>
<li>那什么是原型？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。也可以说是实例原型。特殊情况：函数对象，如果Object、Function，此时他们既有<strong>proto</strong>也有prototype，而且原型为函数<br><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220225-181204622.png" alt="原型为函数 1"></li>
<li><strong>proto</strong>指向该对象的原型，也同时是其构造函数的原型。</li>
<li><strong>prototype</strong>指向该函数的原型，<strong>Object.prototype</strong>指向一个普通对象(普通对象没有prototype属性，所以值是undefined)，它是js原型链的最顶端,它的<code>__proto__</code>是null(有<code>__proto__</code>属性，但值是null，因为这是原型链的最顶端)。所以Object.prototype没有原型 。</li>
</ul>
<pre><code class="js">  Object.prototype.__proto__=== null;//true
  Object.prototype.prototype === undefied;//true 对象没有prototype,除非是函数对象</code></pre>
<ul>
<li>在js中如果A对象是由B函数构造的，那么<code>A.__proto__ === B.prototype</code>。javascript中对象是由Object创建的，函数是由Function创建的。</li>
<li><strong>内置的Object</strong>其实是一个函数对象，它是由Function创建的。<code>Object.__proto__ === Function.prototype;</code></li>
<li><strong>内置的Function</strong>也是一个函数对象，它是通过自己来创建自己的。<code>Function.__proto__=== Function.prototype;//true</code></li>
<li>js中<strong>每一个对象或函数</strong>都有<code>__proto__</code>属性，但是只有<strong>函数对象</strong>才有<strong>prototype</strong>属性。</li>
</ul>
<pre><code class="js">    // 函数对象
    function Person() &#123;&#125;
  // 普通对象
  var obj = &#123;&#125;;

  obj.__proto__ === Object.prototype;//true

    obj.prototype === undefined;//true

    Person.__proto__ === Function.prototype;//true

    Person.prototype !== undefined;//true</code></pre>
<ul>
<li><p>原型链是基于<code>__proto__</code>形成的，继承是通过prototype实现的。</p>
</li>
<li><p>所有函数都有prototype属性，除了Function.prototype外，它是函数对象，但是没有prototype属性。<code>Function.prototype.prototype === undefined;//true</code></p>
</li>
<li><p>函数也是对象，因为<code>Function.prototype.__proto__</code>指向Object.prototype。</p>
</li>
</ul>
<pre><code class="js">    typeof Function.prototype.__proto__) === &quot;object&quot;;//true
    Function.prototype.__proto__=== Object.prototype;//true</code></pre>
<ul>
<li><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链(构造函数是不是对象new)</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbszdheq1j310o0lgabp.jpg" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/2">可参考</a></p>
</li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li>什么是cookie</li>
</ol>
<p>cookie是由服务器生成并保存在客户端的小型文本文件，它的优点是：</p>
<ul>
<li>高扩展性和可用性，比如,可以通过良好的编程控制存储在cookie的信息大小</li>
<li>数据持久性，cookie可以长期保存在浏览器中</li>
<li>一定的安全性，可以设置失效时间，通过加密技术和安全传送技术，防止信息被恶意串改</li>
</ul>
<p>缺点：</p>
<ul>
<li>cookie的长度和同一域名下的数量都有限制，长度不超过4k，数量firefox限制40，chrome没有限制</li>
<li>潜在的安全风险，cookie有可能被攻击者串改，或者被拦截</li>
<li>不适合保存状态，如一些防止表单重复提交的计时器</li>
<li>冗余，服务器不需要的信息也可能随cookie发送</li>
</ul>
<ol start="2">
<li>与session的区别</li>
</ol>
<p>session：服务端执行session机制时候会生成session的id值，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie(Session不一定必须依赖Cookie，也可以在url上)</p>
<h2 id="node事件驱动模型"><a href="#node事件驱动模型" class="headerlink" title="node事件驱动模型"></a>node事件驱动模型</h2><p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220228-165123938.png" alt="图 3">  </p>
<p>关于线程： 除了你的代码是单线程，其余都是多线程（线程池），nodejs本身是事件驱动，一个io事件完成会被放到一个事件队列中，主线程负责轮询这个队列，然后执行相应的回调函数。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">参考1</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html">参考2</a></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">Node.js 事件循环，定时器和 process.nextTick()</a> by node.js</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p><code>process.nextTick</code>这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018022302.png" alt="img"></p>
<p>Node 执行完所有同步任务，接下来就会执行<code>process.nextTick</code>的任务队列。</p>
<p><strong>微任务和宏任务在Node的执行顺序</strong></p>
<p>Node 10以前：</p>
<ul>
<li>执行完一个阶段的所有任务</li>
<li>执行完nextTick队列里面的内容</li>
<li>然后执行完微任务队列的内容</li>
</ul>
<p>Node 11以后：<br>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。</p>
<h3 id="setImmediate-对比-setTimeout"><a href="#setImmediate-对比-setTimeout" class="headerlink" title="setImmediate() 对比 setTimeout()"></a><code>setImmediate()</code> 对比 <code>setTimeout()</code></h3><p><code>setImmediate()</code> 和 <code>setTimeout()</code> 很类似，但是基于被调用的时机，他们也有不同表现。</p>
<ul>
<li><code>setImmediate()</code> 设计为一旦在当前 <strong>轮询</strong> 阶段完成， 就执行脚本。</li>
<li><code>setTimeout()</code> 在最小阈值（ms 单位）过后运行脚本。</li>
</ul>
<p>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时器将受进程性能的约束（这可能会受到计算机上其他正在运行应用程序的影响）。</p>
<p>例如，如果运行以下不在 I/O 周期（即主模块）内的脚本(可以理解为<strong>初始化时</strong>)，则执行两个计时器的顺序是非确定性的，因为它受进程性能的约束：</p>
<blockquote>
<p>当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入 <a target="_blank" rel="noopener" href="https://nodejs.org/api/repl.html#repl_repl">REPL</a>，本文不涉及到），它可能会调用一些异步的 API、调度定时器，或者调用 <code>process.nextTick()</code>，然后开始处理事件循环。</p>
</blockquote>
<pre><code class="js">// timeout_vs_immediate.js
setTimeout(() =&gt; &#123;
  console.log(&#39;timeout&#39;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&#39;immediate&#39;);
&#125;);
$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout</code></pre>
<p>但是，如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用：</p>
<pre><code class="js">// timeout_vs_immediate.js
const fs = require(&#39;fs&#39;);

fs.readFile(__filename, () =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timeout&#39;);
  &#125;, 0);
  setImmediate(() =&gt; &#123;
    console.log(&#39;immediate&#39;);
  &#125;);
&#125;);
$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout</code></pre>
<h2 id="clientWidth和offsetWidth宽度"><a href="#clientWidth和offsetWidth宽度" class="headerlink" title="clientWidth和offsetWidth宽度"></a>clientWidth和offsetWidth宽度</h2><p>ele.clientWidth = 宽度 + padding</p>
<p>ele.offsetWidth = 宽度 + padding + border</p>
<p> ele.scrollTop = 被卷去的上侧距离</p>
<p> ele.scrollHeight = 自身实际的高度，可见部分加上不可见部分（不包括边框）</p>
<p>ele.offsetTop = 当前元素相对于其 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的顶部内边距的距离</p>
<p>Ps：懒加载是利用图片的ele.offsetTop和父元素的scrollTop的差判断图片是否在屏幕范围内</p>
<h2 id="线程和进程的差别"><a href="#线程和进程的差别" class="headerlink" title="线程和进程的差别"></a>线程和进程的差别</h2><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p><strong>常见Web漏洞及其防范</strong></p>
<ul>
<li><p>1.XSS(Cross Site Scripting)跨站脚本攻击</p>
<ul>
<li>攻击方式：利用html的漏洞，让网页执行不存在的js代码，比如在评论里写进代码，用户浏览到当条评论就会执行此段代码</li>
<li>防范：客户端与服务端同时做htmlEncode和jsEncode。服务端保障安全，客户端提升体验。服务端可使用XSS Filter实现，nodejs可使用XSS相关中间件。</li>
</ul>
</li>
<li><p>2.CSRF（Cross-site request forgery）跨站请求伪造</p>
<ul>
<li>方式：伪装成用户发请求，如劫持用户cookie获取请求，伪装成用户进行银行卡转账</li>
<li>防范：通过HTTP的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/06/http-referer.html">Referer</a>字段验证请求是否来自信任网站</li>
</ul>
</li>
<li><p>3.SQL注入</p>
<ul>
<li>方式：SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作。例如：网页查询界面，在input注入sql</li>
<li>防范：服务器对查询的SQL语句进行预编译、校验请求参数。例如：nodejs使用sqlstring对sql语句进行预编译</li>
</ul>
</li>
<li><p>4.弱口令<br>防范：使用规则限制用户使用弱口令</p>
</li>
<li><p>5.非加密传输<br>防范：使用HTTPS(HTTPS原理：非对称加密交换密钥+对称加密数据+CA认证)</p>
</li>
<li><p>6.CFS(Cross Frame Script跨框架脚本攻击)与Clickjacking(点击劫持)</p>
<ul>
<li><p>方式：利用浏览器允许框架(frame)跨站包含其它页面的漏洞，在主框架的代码中加入scirpt，监视、盗取用户输入。</p>
</li>
<li><p>防范：服务端header设置X-Frame-Options为SAMEORIGIN</p>
</li>
<li><p>tip：使用 X-Frame-Options 有三个可选的值：</p>
<p>DENY：浏览器拒绝当前页面加载任何Frame页面</p>
<p>SAMEORIGIN：frame页面的地址只能为同源域名下的页面</p>
<p>ALLOW-FROM：允许frame加载的页面地址</p>
</li>
</ul>
</li>
</ul>
<h2 id="http2和http1的区别"><a href="#http2和http1的区别" class="headerlink" title="http2和http1的区别"></a>http2和http1的区别</h2><h2 id="虚拟dom的原理"><a href="#虚拟dom的原理" class="headerlink" title="虚拟dom的原理"></a>虚拟dom的原理</h2><h2 id="如果要实现一个组件的动态加载，会用webpack的什么方法"><a href="#如果要实现一个组件的动态加载，会用webpack的什么方法" class="headerlink" title="如果要实现一个组件的动态加载，会用webpack的什么方法"></a>如果要实现一个组件的动态加载，会用webpack的什么方法</h2><h2 id="ajax实现"><a href="#ajax实现" class="headerlink" title="ajax实现"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018935873">ajax实现</a></h2><h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><p>任务执行顺序： 同步任务、异步任务(顺序：微任务（promise，nextTick）、宏任务(setTimeout，setInterval、setImmediate))</p>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b498d245188251b193d4059#heading-6]">宏任务与微任务</a></p>
<h2 id="什么是reflow和repaint"><a href="#什么是reflow和repaint" class="headerlink" title="什么是reflow和repaint"></a>什么是reflow和repaint</h2><blockquote>
<p>repaint（重绘）：如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint。repaint 的速度明显快于 reflow</p>
<p>reflow（回流）：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。</p>
</blockquote>
<p>reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>下面情况会导致reflow发生</p>
<p>1：改变窗口大小</p>
<p>2：改变文字大小</p>
<p>3：内容的改变，如用户在输入框中敲字</p>
<p>4：激活伪类，如:hover</p>
<p>5：操作class属性</p>
<p>6：脚本操作DOM</p>
<p>7：计算offsetWidth和offsetHeight</p>
<p>8：设置style属性</p>
<p>相关扩展：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33629083">在移动端使用transform: translate代替top left marg等做位移有好处么 ？</a></p>
<h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><p>新建一个对象，并把this指向这个对象，同时使该对象继承函数的原型</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">参考</a></p>
<h2 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h2><pre><code class="js">function parent(name) &#123;
    this.name = name

    return &#123;
        name: &#39;刘&#39;
    &#125;
&#125;

parent.prototype.car = &#39;bigCar&#39;

child = new parent(&#39;张&#39;)

console.log(&#39;child&#39;, child)

// 模拟实现

function _new() &#123;

    const  constructor = [].slice.call(arguments, 0, 1)[0]

    const arg = [].slice.call(arguments, 1)

    const obj = new Object()

    const ret = constructor.apply(obj, arg)

    obj.__proto__ = constructor.prototype

    return  ret instanceof Object ? ret : obj
&#125;

child1 = _new(parent, &#39;林&#39;)

console.log(&#39;child1&#39;, child1)</code></pre>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><ol>
<li><p>意外的全局变量， 在JavaScript文件中添加<code>&#39;use strict&#39;</code>，开启严格模式</p>
</li>
<li><p>闭包</p>
<ol>
<li><p>注意: 闭包本身没有错,不会引起内存泄漏.而是使用错误导致.</p>
</li>
<li><p>如闭包return回来的函数没有被使用的话，就好造成内存泄露，还有一些其他场景</p>
</li>
<li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大</p>
</li>
<li><p>循环引用</p>
</li>
</ol>
<pre><code class="js">   function handle () &#123;
       var element = document.getElementById(“testId”);
      // 闭包
       element.onclick = function ()&#123;
           alert(element.id)
       &#125;
   &#125;</code></pre>
<p>   闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</p>
<p>   Ps: 可以<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31078912">参考</a></p>
</li>
<li><p>被遗忘的定时器和回调函数 在定时器完成工作的时候，手动清除定时器</p>
</li>
<li><p>DOM引用，保留了DOM节点的引用,导致GC没有回收</p>
</li>
<li><p>遗忘的事件监听器，如在单页面应用，组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收，需要在组件销毁的时候移除相关的事件</p>
</li>
</ol>
<p>参考 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020231307#item-5-5">内存泄露</a></p>
<h2 id="http-2-0对于http-1-x有哪些优点？"><a href="#http-2-0对于http-1-x有哪些优点？" class="headerlink" title="http 2.0对于http 1.x有哪些优点？"></a>http 2.0对于http 1.x有哪些优点？</h2><ol>
<li><p>多路复用，多个http请求复用一个连接</p>
<blockquote>
<p>HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br>多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中</p>
<ul>
<li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>单个连接上可以并行交错的请求和响应，之间互不干扰</li>
</ul>
</blockquote>
</li>
<li><p>二进制分帧，在应用层和传输层直接加了一个二进制分帧，把http请求的数据分割成更小的二进制帧，从而实现多个数据流复用同一个连接的目的，减轻了服务器的连接压力</p>
</li>
<li><p>首部压缩，采用了HPACH的新算法进行首部压缩，减轻报文体积</p>
</li>
<li><p>服务器推送，类似websocket</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34074946">参考</a></p>
<h2 id="virtualDOM是什么"><a href="#virtualDOM是什么" class="headerlink" title="virtualDOM是什么"></a>virtualDOM是什么</h2><p>virtualDOM是DOM节点树的一个映射</p>
<p>使用原因：真实dom依赖环境，操作开销大，节点渲染频繁</p>
<p>它的作用是，每次数据变化时，通过virtualDOM执行diff算法进行对比得到差异结果后，再一次性对DOM进行批量更新操作</p>
<p>diff算法不是传统意义上的通过深度优先遍历DFS算法算法，它做了以下几点改进：</p>
<ol>
<li><p>同层级的节点进行比较</p>
<p>在新旧节点树之间按层级进行diff得到差异，可以算法复杂度降低到O(n)</p>
</li>
<li><p>按类型进行diff</p>
<p>VirtualDOM只对相同类型的同一个节点进行diff，当新旧节点发生了类型的改变时，则并不进行子树的比较，直接创建新类型的VirtualDOM，替换旧节点</p>
<p>例如同类型的组件照常进行比较，不同类型的组件不进行比较直接替换节点</p>
</li>
<li><p>列表按key进行diff</p>
<p>在没有key值的列表diff中，只能通过按顺序进行每个元素的对比，更新，插入与删除</p>
<p>如果有key就能够快速识别新旧列表之间的变化内容</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d81eec56fb9a06add4e63ba">参考</a></p>
<h2 id="webpack性能优化汇总"><a href="#webpack性能优化汇总" class="headerlink" title="webpack性能优化汇总"></a><a target="_blank" rel="noopener" href="https://juejin.im/post/5dcc45136fb9a02b450c2818">webpack性能优化汇总</a></h2><ol>
<li><p>减少打包时间</p>
<ol>
<li>优化loader配置</li>
<li>happyPack插件开启多线程打包</li>
</ol>
</li>
<li><p>减少打包后的体积</p>
<ol>
<li>使用CDN放置部分资源</li>
<li>UglifyJS代码压缩</li>
</ol>
</li>
<li><p>优化打包质量</p>
<ol>
<li>分割代码以按需加载</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b652b036fb9a04fa01d616b#heading-16">参考</a></p>
<h2 id="组件设计原则"><a href="#组件设计原则" class="headerlink" title="组件设计原则"></a>组件设计原则</h2><ol>
<li>低耦合高内聚，</li>
<li>分清业务组件和通用组件</li>
<li>健壮性，保证能在各种场合适用</li>
</ol>
<h2 id="node中间件的原理"><a href="#node中间件的原理" class="headerlink" title="node中间件的原理"></a>node中间件的原理</h2><p>一个请求发送到服务器后，它的生命周期是 先收到request（请求），然后服务端处理，处理完了以后发送response（响应）回去</p>
<p>app.use 加载用于处理http请求的middleware（中间件），当一个请求来的时候，会依次被这些 middlewares处理。</p>
<p>中间件其是一个函数，在响应发送之前对请求进行一些操作</p>
<p>这个函数有些不太一样，它还有一个next参数，而这个next也是一个函数，它表示函数数组中的下一个函数</p>
<p>express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组</p>
<p>ps：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1467268">koa与express的中间件机制揭秘</a> by 挥刀北上</p>
<h2 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。</td>
</tr>
<tr>
<td>HEAD</td>
<td>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</td>
</tr>
<tr>
<td>POST</td>
<td>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。</td>
</tr>
<tr>
<td>TRACE</td>
<td>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b004085f265da0b886daf7c">参考</a></p>
<h2 id="关于-javascript-中的-this"><a href="#关于-javascript-中的-this" class="headerlink" title="关于 javascript 中的 this"></a>关于 javascript 中的 this</h2><p>javascript 中的 this 和 OO 语言（如：java、C#）的 this 有着比较大的差异。</p>
<ul>
<li>1 请说明下方代码片段中对于 this 的使用是否正确，不正确的话，问题在哪里，如何修改？</li>
<li>2 写些小的代码片段说明一下你理解的 this。</li>
</ul>
<pre><code class="javascript">class Handler &#123;
  get (req, res) &#123;
    const type = req.query.type
    this[type](req, res)
  &#125;

  typeA (req, res) &#123;
    res.send(&#39;hello a&#39;)
  &#125;

  typeB (req, res) &#123;
    res.send(&#39;hello b&#39;)
  &#125;
&#125;

const express = require(&#39;express&#39;)
const app = express()

const handler = new Handler()
app.use(&#39;/&#39;, handler.get)</code></pre>
<p>答：</p>
<ul>
<li>不正确，问题在执行<code>app.use(&#39;/&#39;, handler.get)</code> 时,改变了this的指向， 因为此时函数中的this是根据上下文指定的</li>
<li>修改方式:</li>
</ul>
<pre><code class="javascript">const handler = function (req, res) &#123;
  const hand = new Handler()
  hand.get(req, res)
&#125;

app.use(&#39;/&#39;, handler)
</code></pre>
<ul>
<li>代码片段：</li>
</ul>
<pre><code class="js">const fun = function() &#123; console.log(this) &#125;
fun() //指向全局

const obj = &#123; objFun : fun &#125;
obj.objFun() //指向obj

fun.call(obj) //指向obj

const person = function () &#123; this.name = &#39;lili&#39; &#125;
myName = new person()
console.log(myName.name) //&#39;lili&#39;

const func = () =&gt; &#123; console.log(this) &#125;
func() //指向全局
func.call(obj) //指向全局</code></pre>
<h2 id="简述-HTTPS-的工作原理，如何实现的加密传输"><a href="#简述-HTTPS-的工作原理，如何实现的加密传输" class="headerlink" title="简述 HTTPS 的工作原理，如何实现的加密传输"></a>简述 HTTPS 的工作原理，如何实现的加密传输</h2><p>答：</p>
<p>简单描述下，https的是对网页整体内容进行加密，从而防止第三方恶意利用网站的加密传输技术</p>
<p>一般用户请求https时：</p>
<ul>
<li>客户端，把支持的加密方法（非对称加密：RSC，ECC，对称加密：DES，RC）、协议版本，生成随机码(客户端随机码 )发送到服务器</li>
<li>服务端选择其中一种加密方式和服务端随机码发送到客户端</li>
<li>客户端验证证书否有效后，生成随机key，用公钥加密字符串(客户端随机码+服务端随机码+随机key )，发送到服务端</li>
<li>服务端生用私钥解码字符串(客户端随机码+服务端随机码+随机key )，然后使用其作为对称加密的密码加密网页，返回网页给客户端</li>
<li>客户端获取加密网页，使用字符串(客户端随机码+服务端随机码+随机key )对内容进行解码，得到正确数据并显示在浏览器上</li>
</ul>
<p>上述过程只是根据个人记忆理解的描述，跟具体的步骤可能有些出入</p>
<p>这里有几个问题想说明下：</p>
<ul>
<li>为什么不直接使用公钥加密网页？因为网页往往较大，用公钥加密一般比较费时，而对称加密效率高但安全性低，故此选择了非对称加密和对称加密结合的方式进行</li>
<li>为什么要加入随机key？随机key是最重要的钥匙，和客户端随机码、服务端随机码是明文传输不一样，它是唯一不会被中间人获取的key。</li>
</ul>
<h2 id="介绍一下-import-和-require-有什么区别"><a href="#介绍一下-import-和-require-有什么区别" class="headerlink" title="介绍一下 import 和 require 有什么区别"></a>介绍一下 import 和 require 有什么区别</h2><p>答：</p>
<p>import：es6的模块加载规范，可用于浏览器环境和node环境(需要babal)</p>
<p>require：commonJS的加载规范，主要用于node环境</p>
<h2 id="什么是事件捕获机制，DOM0和DOM2"><a href="#什么是事件捕获机制，DOM0和DOM2" class="headerlink" title="什么是事件捕获机制，DOM0和DOM2"></a>什么是事件捕获机制，DOM0和DOM2</h2><p>1、DOM0级事件</p>
<p>就是直接通过 onclick 等方式实现相应的事件</p>
<p>这说明 DOM0 级添加事件时，后面的事件会覆盖前面的事件，而 DOM2级则不会，多个事件都会执行；</p>
<p>另外，DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p>
<p>2、DOM1级事件</p>
<p>因为DOM 1一般只有设计规范没有具体实现,所以一般跳过</p>
<p>3、</p>
<p>DOM2级事件</p>
<p><strong>主流浏览器 DOM2 级事件是通过以下两个方法用于处理指定和删除事件处理程序的操作</strong></p>
<p><strong>只有**</strong>DOM2事件流包括三个阶段**：</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p>即是事件捕获机制</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leophen/p/11405579.html">参考</a></p>
<h2 id="理解变量提升"><a href="#理解变量提升" class="headerlink" title="理解变量提升"></a>理解变量提升</h2><ol>
<li>变量函数都会提升</li>
<li>函数声明提升(包括function(){}里面也算函数声明)</li>
<li>变量声明提升，不会提升赋值</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d36b06af265da1ba84ad143#heading-3">参考</a></p>
<h2 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h2><ol>
<li><em>变量声明、函数声明都会被提升到作用域顶处；</em></li>
<li>当出现相同名称时，优先级为：<strong>变量声明(foo#1) &gt; 函数声明(foo#2) &gt; 变量赋值(foo#3)*</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/5">参考</a></p>
<h2 id="前端模块化：CommonJS-AMD-CMD-ES6"><a href="#前端模块化：CommonJS-AMD-CMD-ES6" class="headerlink" title="前端模块化：CommonJS,AMD,CMD,ES6"></a>前端模块化：CommonJS,AMD,CMD,ES6</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aaa37c8f265da23945f365c">参考</a></p>
<h2 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h2><ol>
<li><p>原型链继承 缺点：引用类型值的原型属性会被所有实例共享</p>
<pre><code class="js">function Parent() &#123;
    this.name = &#39;父亲&#39;; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
&#125;
Parent.prototype.say = function() &#123; // -- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
&#125;
function Child(like) &#123;
    this.like = like;
&#125;
Child.prototype = new Parent() // 核心

let boy1 = new Child()
let boy2 = new Child()</code></pre>
<p>补充：实际上所有类型的属性都会被共享，只不过值类型的属性，在修改时会在对象上新建属性覆盖，而值类型通过一些不改变原始地址的方式修改值时，所有实例都会被修改，因为此时实例记录的都是同一个原始地址</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsqldzsj30s80jw0v2.jpg" alt="image-20200330115542949" style="zoom:50%;" />
</li>
<li><p>借用构造函数继承 缺点：父类的方法不能复用,每次都要新建一次方法</p>
<pre><code class="js">function Parent(name) &#123;
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
     this.arr = [1]; // (该属性，强调私有)
    this.say = function() &#123; // 实例引用属性 (该属性，强调复用，需要共享)
        console.log(&#39;hello&#39;)
    &#125;
&#125;
function Child(name,like) &#123;
    Parent.call(this,name);  // 核心
    this.like = like;
&#125;
let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;);
let boy2 = new Child(&#39;小明&#39;, &#39;orange &#39;);</code></pre>
</li>
<li><p>组合继承 缺点：两次调用构造方法</p>
<pre><code class="js">function Parent(name) &#123;
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
&#125;
Parent.prototype.say = function() &#123; // --- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
&#125;
function Child(name,like) &#123;
    Parent.call(this,name) // 核心   第二次
    this.like = like;
&#125;
Child.prototype = new Parent() // 核心   第一次

&lt;!--这里是修复构造函数指向的代码--&gt;

let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;)
let boy2 = new Child(&#39;小明&#39;,&#39;orange&#39;)</code></pre>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015216289#item-2-5">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/16">参考2</a></p>
<h2 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h2><ol>
<li><p>Object对象函数和对象字面量</p>
</li>
<li><p>工厂模式</p>
<p>用函数创造一个对象</p>
<p>缺点：没有解决对象识别的问题？</p>
<pre><code class="js">function person(name) &#123;
  let obj = new Object()
  obj.name = name
  obj.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>原型链模式</p>
<p>用类创造一个对象</p>
<p>缺点：共享了方法属性</p>
<pre><code class="js">function person() &#123;
&#125;
person.prototype.name = name
person.prototype.say = function()&#123;
  alert(&#39;say&#39;)
&#125;
let person1 = new preson()</code></pre>
</li>
<li><p>构造函数模式</p>
<p>用类创造一个对象</p>
<p>缺点：每次新建时方法都会被创建一次</p>
<pre><code class="js">function person(name) &#123;
  this.name = name
  this.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>组合使用原型链模式和构造函数模式<br>用类创造一个对象</p>
<pre><code class="js">function person(name) &#123;
  this.name = name
  this.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
person.prototype = &#123;
  constructor: person,
  say: function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
</ol>
<h2 id="vue组件通信的方式"><a href="#vue组件通信的方式" class="headerlink" title="vue组件通信的方式"></a>vue组件通信的方式</h2><ol>
<li><p>父组件向子组件</p>
<blockquote>
<p>props：从上往下传</p>
<p>$children：获取父组件额属性</p>
<p>Porvide/inject： 在父组件中通过 <code>provider</code> 来提供属性，然后在子组件中通过 inject 来注入变量，深层级应对</p>
</blockquote>
</li>
<li><p>子组件向父组件</p>
<blockquote>
<p><code>$emit</code>： 传入事件和参数，父组件用<code>$on</code>监听</p>
<p>$parent</p>
</blockquote>
</li>
<li><p>其他</p>
<blockquote>
<p>中央事件总线EventBus：通过新建一个 <code>Vue</code> 事件 <code>bus</code> 对象，然后通过 <code>bus.$emit</code> 触发事件，<code>bus.$on</code> 监听触发的事件</p>
<p>vuex</p>
</blockquote>
</li>
</ol>
<h2 id="前端常用的设计模式"><a href="#前端常用的设计模式" class="headerlink" title="前端常用的设计模式"></a>前端常用的设计模式</h2><ol>
<li><p>工厂模式</p>
<blockquote>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</p>
</blockquote>
<p>例子：父类就像工厂生产自行车，可能会有轮子、把手、踩踏板、刹车，但是不同型号的自行车会有不同的东西如变速器，这些交给子类生产线复制</p>
</li>
<li><p>单例模式</p>
<blockquote>
<p>一个单一的类，该类负责创建自己的对象，同时确保只有<strong>单个对象</strong>被创建，并提供一个访问它的全局访问点</p>
</blockquote>
<p>例子： 前端弹窗的实现，调用多次弹窗函数，只实例化一次弹窗</p>
</li>
<li><p>代理模式</p>
<blockquote>
<p>为其他对象提供一种代理层以控制对这个对象的访问，不直接访问对象</p>
</blockquote>
<p>例子：限制接口频繁访问访问数据库，可以做一层代理，一段时间</p>
</li>
<li><p>观察者模式</p>
<blockquote>
<p>存在一对多关系时，则使用观察者模式</p>
</blockquote>
<p>例子：vue的双向绑定，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p>vs：</p>
<p>发布/订阅模式</p>
<blockquote>
<p>之前是观察者模式的别名，现在有所区别，发布订阅模式相比观察者模式多了个事件通道作为调度中心</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmpgz17qoj30fe0acgp9.jpg" alt="img"></p>
</blockquote>
</li>
<li><p>状态模式</p>
<blockquote>
<p>关键是区分事物内部的状态，事物内部状态往往会带来事物的行为改变，即允许对象在内部状态发生改变时改变它的行为</p>
</blockquote>
</li>
<li><p>职责链模式</p>
<blockquote>
<p> 处理请求组成的一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象</p>
</blockquote>
</li>
<li><p>策略模式</p>
<blockquote>
<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</blockquote>
<p>例子：表单验证的实现，表单的各种校验函数封装成策略对象，通过外部参数组合使用表单校验</p>
</li>
<li><p>适配器模式</p>
<blockquote>
<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>
</blockquote>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tugenhua0707/p/5198407.html">Javascript设计模式详解</a></p>
<h2 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h2><ol>
<li><p>单一职责原则</p>
<blockquote>
<p>单一职责原则，一个类只提供一种功能，不要存在过多导致类变化的原因。</p>
</blockquote>
</li>
<li><p>开放封闭原则</p>
<blockquote>
<p>类，方法等应当对其扩展开放，对其修改封闭</p>
</blockquote>
</li>
<li><p>里氏替换原则</p>
<blockquote>
<p>子类必须能够替换它们的基类。</p>
</blockquote>
</li>
<li><p>依赖倒置原则</p>
<blockquote>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p>
</blockquote>
</li>
<li><p>接口分离原则</p>
<blockquote>
<p>使用多个专门的接口来取代一个统一的接口</p>
</blockquote>
</li>
<li><p>最少知识原则</p>
<blockquote>
<p>就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话</p>
</blockquote>
</li>
</ol>
<h2 id="amqp"><a href="#amqp" class="headerlink" title="amqp"></a><a target="_blank" rel="noopener" href="https://juejin.im/post/5dfc93a5f265da339b500273">amqp</a></h2><h2 id="高性能建站指南"><a href="#高性能建站指南" class="headerlink" title="高性能建站指南"></a>高性能建站指南</h2><ol>
<li>减少http请求 方式：合并css、js文件，使用精灵图</li>
<li>使用cdn加快加载速度</li>
<li>开启浏览器缓存</li>
<li>css放头部，减少白屏，防止其阻碍页面呈现，页面会等css加载完再呈现内容</li>
<li>js放底部，防止其阻塞资源并行加载，不能并行加载的原因是保证js的顺序</li>
<li>开启服务器gzip压缩</li>
</ol>
<h2 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与,</p>
<p>哪些情况会产生BFC:</p>
<ol>
<li><p>根元素</p>
</li>
<li><p>float属性不为none</p>
</li>
<li><p>position为absolute或fixed</p>
</li>
<li><p>display为inline-block, table-cell, table-caption, flex, inline-flex</p>
</li>
<li><p>overflow不为visible</p>
</li>
</ol>
<p>BFC 特性及应用：</p>
<ul>
<li>同一个 BFC 下外边距会发生重叠</li>
<li>内部第一层计算高度时浮动的元素参与计算（清除浮动）</li>
<li>内部第一层浮动元素不重叠（其实同上）</li>
<li>应用：用来实现<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903817104850952#heading-4">两列自适应布局</a></li>
</ul>
<h2 id="CSS-百分比参照问题"><a href="#CSS-百分比参照问题" class="headerlink" title="CSS 百分比参照问题"></a>CSS 百分比参照问题</h2><ul>
<li>参照父元素<strong>宽度</strong>的元素：padding <strong>margin</strong> width text-indent</li>
<li>参照父元素高度的元素：height</li>
<li>参照父元素属性:font-size line-height</li>
<li>参照transform-box（可能为当前元素）属性：transform: translate(30%, 50%);</li>
<li>特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度</li>
</ul>
<h2 id="React-组件的生命周期方法"><a href="#React-组件的生命周期方法" class="headerlink" title="React 组件的生命周期方法"></a>React 组件的生命周期方法</h2><p>一些最重要的生命周期方法是：</p>
<ol>
<li><strong><em>componentWillMount**</em></strong>()** – 在渲染之前执行，在客户端和服务器端都会执行。</li>
<li><strong><em>componentDidMount**</em></strong>()** – 仅在第一次渲染后在客户端执行。</li>
<li><strong><em>componentWillReceiveProps**</em></strong>()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</li>
<li><strong><em>shouldComponentUpdate**</em></strong>()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回<strong>true</strong> 否则返回 <strong>false</strong>。默认情况下，它返回 false。</li>
<li><strong><em>componentWillUpdate**</em></strong>()** – 在 DOM 中进行渲染之前调用。</li>
<li><strong><em>componentDidUpdate**</em></strong>()** – 在渲染发生后立即调用。</li>
<li><strong><em>componentWillUnmount**</em></strong>()** – 从 DOM 卸载组件后调用。用于清理内存空间。</li>
</ol>
<h2 id="Node-的-Event-Loop-6个阶段"><a href="#Node-的-Event-Loop-6个阶段" class="headerlink" title="Node 的 Event Loop: 6个阶段"></a>Node 的 Event Loop: 6个阶段</h2><ul>
<li><p>timer 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p>
</li>
<li><p>I/O 阶段: 执行上轮循环残流的<code>callback</code></p>
</li>
<li><p>idle, prepare</p>
</li>
<li><p>poll: 等待回调</p>
<ul>
<li><ol>
<li>执行回调</li>
</ol>
</li>
<li><ol>
<li>执行定时器</li>
</ol>
<ul>
<li>如有到期的<code>setTimeout / setInterval</code>， 则返回 timer 阶段</li>
<li>如有<code>setImmediate</code>，则前往 check 阶段</li>
</ul>
</li>
</ul>
</li>
<li><p>check</p>
<ul>
<li>执行<code>setImmediate</code></li>
</ul>
</li>
<li><p>close callbacks</p>
</li>
</ul>
<h2 id="浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="浏览器与Node的事件循环(Event Loop)有何区别"></a><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/">浏览器与Node的事件循环(Event Loop)有何区别</a></h2><p>node跟浏览器端相差比较大，timers 阶段有几个 setTimeout/setInterval 都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务</p>
<h2 id="H5移动端兼容问题"><a href="#H5移动端兼容问题" class="headerlink" title="H5移动端兼容问题"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015131445">H5移动端兼容问题</a></h2><h2 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h2><ul>
<li>defer：浏览器解析完成后执行，defer之间保证执行顺序</li>
<li><code>async</code>：尽快执行，阻塞解析，不保证顺序</li>
<li>创建<code>script</code>，在onload后，插入到<code>DOM</code>中，加载完毕后<code>callBcak</code></li>
</ul>
<h2 id="判断js数据类型的方法"><a href="#判断js数据类型的方法" class="headerlink" title="判断js数据类型的方法"></a>判断js数据类型的方法</h2><ol>
<li><p>typeof</p>
<ul>
<li>对于基本类型，除 null 以外，均可以返回正确的结果。</li>
<li>除 function 以外，一律返回 object 类型。</li>
<li>对于 null ，返回 object 类型。</li>
<li>对于 function 返回  function 类型</li>
</ul>
</li>
<li><p>instanceof</p>
<ul>
<li><strong>instanceof 检测的是原型</strong></li>
<li><strong>instanceof 只能用来判断两个对象是否属于实例关系</strong> <strong>， 而不能判断一个对象实例具体属于哪种类型。</strong></li>
</ul>
</li>
<li><p>toString</p>
<p><code>Object.prototype.toString.call()</code></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/5126046.html">参考</a></p>
<h2 id="Proxy和defineProperty"><a href="#Proxy和defineProperty" class="headerlink" title="Proxy和defineProperty"></a>Proxy和defineProperty</h2><ul>
<li><p><strong>Object.defineProperty</strong> ：该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象</p>
<pre><code class="js">var obj = &#123;&#125;;
Object.defineProperty(obj, &quot;num&quot;, &#123;
    value : 1,
    writable : true,
    enumerable : true,
    configurable : true
&#125;);
//  对象 obj 拥有属性 num，值为 1
</code></pre>
</li>
<li><p><strong>proxy</strong> ：控制和修改Object的基本行为, 比起defindProperty可以重定义更多的行为，除了 get 和 set 之外，proxy 可以拦截多达 13 种操作</p>
<pre><code class="js">var proxy = new Proxy(target, handler);
/* new Proxy()表示生成一个Proxy实例
target参数表示所要拦截的目标对象
handler参数也是一个对象，用来定制拦截行为。*/
</code></pre>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.im/post/5be4f7cfe51d453339084530#heading-4">ES6 系列之 defineProperty 与 proxy</a></p>
<h2 id="页面性能指标"><a href="#页面性能指标" class="headerlink" title="页面性能指标"></a>页面性能指标</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsdka5bj31pc0n6ti1.jpg" alt="蚂蚁金服如何把前端性能监控做到极致?"></p>
<p>页面加载时长是被清晰的标在这个页面的底部的。它是指 DOM <code>load</code> 事件触发完成，它的优点有：</p>
<ul>
<li>原生 API；</li>
<li>接受度高；</li>
<li>感知明显（浏览器 Tab 停止 loading）。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>无法准确反映页面加载性能；</li>
<li>易受特殊情况影响。</li>
</ul>
<p>为了解决这个问题，W3C 的工作小组引入了首次渲染 / 首次内容渲染。首次渲染是指第⼀个非网页背景像素渲染，⾸次内容渲染是指第一个⽂本、图像、背景图片或非白色 canvas/SVG 渲染。</p>
<p>相关：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohuochai/p/9182710.html">使用chrome开发者工具中的performance面板解决性能瓶颈</a></p>
<h2 id="渲染树的形成原理"><a href="#渲染树的形成原理" class="headerlink" title="渲染树的形成原理"></a><a target="_blank" rel="noopener" href="https://juejin.im/post/5da2f4f7f265da5b8a516502#heading-7">渲染树的形成原理</a></h2><blockquote>
<p>注意点:</p>
<ol>
<li>CSS解析可以与DOM解析同进行</li>
<li>如果只有 CSS 和 HTML 的页面，CSS 不会影响 DOM 树的创建，但是如果页面中还有 JavaScript，结论就不一样了。</li>
</ol>
</blockquote>
<h2 id="Promise-all-和Promise-race模拟实现"><a href="#Promise-all-和Promise-race模拟实现" class="headerlink" title="Promise.all()和Promise.race模拟实现"></a>Promise.all()和Promise.race模拟实现</h2><ol>
<li><p>Promise.all()</p>
<pre><code class="js">
function promiseAll(arg = []) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        let timer = 0
        const rets = new Array(arg.length)

        for(let i = 0; i &lt; arg.length; i++) &#123;
          // Promise.resolve 为了兼容 arg中存在不是Promise的数   
            Promise.resolve(arg[i]).then((res) =&gt; &#123;
                rets[i] = res
                timer++
               // 重点，在最后一个完成事执行resolve，最终返回[]
                if(timer === arg.length) resovle(rets)
            &#125;).catch(e =&gt; reject(e))
        &#125;
    &#125;)
&#125;

promiseAll([Promise.resolve(1), Promise.resolve(2), 3]).then((res) =&gt; console.log(res))
// promiseAll([Promise.resolve(1), Promise.reject(2), 3, () =&gt; 4]).then((res) =&gt; console.log(res))</code></pre>
</li>
<li><p>Promise.race()</p>
<pre><code class="js">function promiseRace(arg = []) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    for(let i = 0; i &lt; arg.length; i++) &#123;
      Promise.resolve(arg[i]).then(res =&gt; &#123;
       // 有返回直接返回   
        resolve(res)
      &#125;).catch(e =&gt; reject(e))
    &#125;
  &#125;)
&#125;

promiseRace([new Promise(res =&gt; setTimeout(()=&gt; res(1), 100)), new Promise(res =&gt; setTimeout(()=&gt; res(2), 200))])
  .then((res) =&gt; console.log(res))</code></pre>
<p>关于Promise的更多实现可<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904063570542599#heading-4">参考</a>（此文章，实现有些许冗余）</p>
</li>
</ol>
<p>Generators原理</p>
<p>通过利用闭包，保存生成器函数的上下文，并对生成器函数进行包装添加next方法，似的对next的调用进入到状态机里，而实现next对生成器里面代码的暂停恢复控制。</p>
<p>简单的实例：</p>
<pre><code class="js">function* example() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;
var iter=example();
iter.next();//&#123;value:1，done:false&#125;
iter.next();//&#123;value:2，done:false&#125;
iter.next();//&#123;value:3，done:false&#125;
iter.next();//&#123;value:undefined，done:true&#125;</code></pre>
<p><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2016/02/generators-in-depth/">参考</a></p>
<h2 id="webpack-中-loader-和-plugin-的区别是什么"><a href="#webpack-中-loader-和-plugin-的区别是什么" class="headerlink" title="webpack 中 loader 和 plugin 的区别是什么"></a>webpack 中 loader 和 plugin 的区别是什么</h2><ul>
<li><p>loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。</p>
</li>
<li><p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p>
</li>
</ul>
<h2 id="Vue-中的-computed-是如何实现的"><a href="#Vue-中的-computed-是如何实现的" class="headerlink" title="Vue 中的 computed 是如何实现的"></a>Vue 中的 computed 是如何实现的</h2><p>computed本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的getter，而不是用户定义的方法。</p>
<p>computed内部实现了一个惰性的watcher，在实例化的时候不会去求值，其内部通过dirty属性标记计算属性是否需要重新求值。当computed依赖的任一状态（不一定是return中的）发生变化，都会通知这个惰性watcher，让它把dirty属性设置为true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p>
<p><a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html#computed">参考</a></p>
<h2 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h2><p>!important &gt; 内联 &gt; id &gt; class（=伪类、属性选择器） &gt; 标签选择器（=伪元素）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41604775">参考</a></p>
<h2 id="如何修复输出值中的-undefined-？-阿里"><a href="#如何修复输出值中的-undefined-？-阿里" class="headerlink" title="如何修复输出值中的 undefined ？(阿里)"></a>如何修复输出值中的 undefined ？(阿里)</h2><pre><code class="javascript">function LateBloomer()&#123;
    this.petalCount = Math.ceil(Math.random()*2 + 1);
&#125;
LateBloomer.prototype.bloom = function()&#123;
    window.setTimeout(this.declare, 1000);
&#125;
LateBloomer.prototype.declare = function()&#123;
    console.log(&#39;I am a beautiful flower with &#39; + this.petalCount + &#39; petals&#39;);
&#125;
var flower = new LateBloomer();
flower.bloom();</code></pre>
<h2 id="普通函数和箭头函数this的区别"><a href="#普通函数和箭头函数this的区别" class="headerlink" title="普通函数和箭头函数this的区别"></a>普通函数和箭头函数this的区别</h2><p>区别：</p>
<p><strong>普通函数中的this:</strong></p>
<ol>
<li>this总是代表它的直接调用者, 例如 obj.func ,那么func中的this就是obj</li>
<li>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window</li>
<li>如果该函数是一个构造函数，this指针指向一个新的对象</li>
<li>在严格模式下,没有直接调用者的函数中的this是 undefined</li>
<li>使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象</li>
</ol>
<p><strong>箭头函数中的this</strong></p>
<ol>
<li>默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）</li>
<li>箭头函数不会创建自己的<code>this</code>它只会从自己的<a target="_blank" rel="noopener" href="https://chinese.freecodecamp.org/news/javascript-lexical-scope-tutorial/#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Lexical%20Scope%EF%BC%89,%E5%8F%88%E5%8F%AB%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%82">词法作用域链</a>的上一层继承<code>this</code></li>
<li>call,apply,bind不改变this指向</li>
<li>不能作为构造函数</li>
<li>没有argument属性</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">参考</a></p>
<h2 id="vue-nextTick实现"><a href="#vue-nextTick实现" class="headerlink" title="vue nextTick实现"></a>vue nextTick实现</h2><p>注意：dom的更新是同步的，前一步更新后一步就能拿到结果，所以nextTick能获取dom操作后的结果</p>
<p><a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">参考</a></p>
<h2 id="redux简述"><a href="#redux简述" class="headerlink" title="redux简述"></a>redux简述</h2><p>生成一个使用action变更的state，使用reduer进行管理（传入state和action返回一个新的state）</p>
<h2 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h2><ul>
<li>useEffect怎么替代componentDidMount，可以第二个参数传入[],如：<code>useEffect(()=&gt; &#123;&#125;, [])</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html">参考</a></p>
<h2 id="webpack异步加载原理"><a href="#webpack异步加载原理" class="headerlink" title="webpack异步加载原理"></a>webpack异步加载原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ywl570717586/article/details/79034322?ops_request_misc=&request_id=&biz_id=102&utm_term=webpack%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-79034322.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">参考</a></p>
<h2 id="遇到大量if的代码如何优化"><a href="#遇到大量if的代码如何优化" class="headerlink" title="遇到大量if的代码如何优化"></a>遇到大量if的代码如何优化</h2><p>记住下面的口诀：</p>
<p>互斥条件表驱动</p>
<p>嵌套条件校验链</p>
<p>短路条件早return</p>
<p>零散条件可组合</p>
<blockquote>
<ol>
<li>互斥条件，表示几个条件之间是冲突的，不可能同时达成的。比如说一个数字，它不可能同时是4和2。在这种情况下用表驱动就非常合适，表驱动的核心是key-handler，拿某个key去对应某个handler，只要条件符合key，那么就执行对应的handler。</li>
<li>嵌套条件，表示几个条件是必须同时达成的，比如，只有在手机号码格式正确的情况下才执行某个操作，格式正确就包括必须是字符串、长度为11位、所有位都是数字这些条件，那么就可以使用校验链，比如通过描述的校验链：”string&amp;size:11&amp;numchar:0,*”。能用的形式很多，你可以直接使用&amp;&amp;逻辑运算符拼接条件，也可以把规则写成Validator。</li>
<li>短路条件，表示只要某个条件满足了，那么就不用再继续下面的任何操作了。比如传进来的参数是null、参数如果为0，就不会有其他操作等情况，都可以聚合这些条件，在一开始的时候就判断并且直接返回，或者程序在中间会产生一些可以直接判断为不需要继续往下操作的条件，那么同样是直接在当场就return。</li>
<li>零散条件，是指存在以上三种任意组合的条件形式，那么就可以通过组合这些解决方案。例如，遇到null，直接短路返回，然后之后的代码使用表驱动来区分互斥条件，在达成某个互斥条件的时候，通过校验链来验证嵌套条件等。</li>
</ol>
</blockquote>
<h2 id="获取DOM元素大小"><a href="#获取DOM元素大小" class="headerlink" title="获取DOM元素大小"></a>获取DOM元素大小</h2><ol>
<li>偏移量<ol>
<li>offsetWidth：偏移宽度 = content + padding + border</li>
<li>offsetHeight：偏移高度 = content + padding + border</li>
<li>offsetTop： 相对于offsetParent的偏移顶部 = border上边界 ~ parent的border上边界</li>
<li>offsetLeft：相对于offsetParent的偏移左侧部分 = border左边界 ~ parent的border左边界</li>
</ol>
</li>
<li>客户区大小<ol>
<li>clientWidth： 客户区宽度 = content + padding</li>
<li>clientHeight：客户区高度 = content + padding</li>
</ol>
</li>
<li>滚动大小<ol>
<li>scrollWidth： 滚动区域宽度 = content</li>
<li>scrollHeight： 滚动区域高度 = content</li>
<li>scrollTop： 滚动区域顶部被遮住的内容</li>
<li>scrollLeft：滚动左边被遮住的内容</li>
</ol>
</li>
<li>getBoundingClientRect 返回left、right、top、bottom、width、height（与offsetXXXX一致，不知道为啥叫clientRect）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220314-225321438.png" alt="图 1"></p>
<h2 id="react-hook的优缺点"><a href="#react-hook的优缺点" class="headerlink" title="react hook的优缺点"></a>react hook的优缺点</h2><ul>
<li>优点<ul>
<li>易于复用，可以组合各种hook，方便移植</li>
<li>代码量更少</li>
</ul>
</li>
<li>缺点<ul>
<li>响应式的useEffect，形成一条依赖链，没有componentDidmount生命周期好用。</li>
<li>不擅长异步。容易引入组件的旧值，类似闭包。解决：useRef保存引用。</li>
<li>不能放在if 语句里面使用。因为组件hookStates存放hooks数据，state判断调用哪个hook，是通过hook的调用顺序，if会使得调用顺序不可控。</li>
</ul>
</li>
<li>避免缺点：<ul>
<li>useEffect尽量少依赖</li>
<li>组件划分小而完整</li>
<li>异步尝试传入从组件传入函数参数</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88593858">参考</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1249118795@qq.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '82a6fcaf7cba18f76843',
            clientSecret: '26bace5e3f3042d51108e0ac7400afb6fe450660',
            repo: 'adam-tan.github.io',
            owner: 'adam-tan',
            admin: ['adam-tan'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10),
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 tanjiajian
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
