<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法</title>
    <url>/2022/11/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>堆是任意节点值满足大于等于（大根堆）或小于等于（小根堆）左右子节点值的完全二叉树</p>
<p><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303231303431323231313933362e706e67-20221115181615428.png" alt="img"></p>
<h4 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h4><p>堆的数组表示：可以用序号 1 ~ k 表示 k 个节点，如有一个节点序号为 k，那么父节点必定是 k/2 （取整），左子节点和右子节点分别为 2k 和 2k + 1 （也可以从 0 ~ k - 1 表示 k 个节点）</p>
<p>堆的操作方式：</p>
<ul>
<li><p>插入（上移）：从下往上，节点插入堆尾，然后调整：比父节点大就交换位置（大根堆），重复调整直到不需要调整或者到根节点</p>
</li>
<li><p>弹出（下移）：从上往下，取出堆顶，最后一个节点移动到堆顶，然后从上往下调整堆，直到不需要调整或者到根节点</p>
</li>
</ul>
<p>创建堆的方式有：</p>
<ul>
<li>插入式创建<ul>
<li>从前往后，从下往上：新建新的堆数组，对于需要排序的堆数组从前往后遍历节点，每一次把新的节点插入新的堆数组堆尾，然后调整：比父节点大就交换位置（大根堆），重复调整直到不需要调整或者到根节点</li>
</ul>
</li>
<li>原地创建（堆化）<ul>
<li>从前往后，从下往上：对于堆数组从前往后遍历节点，每一次跟上层的父节点进行对比，然后调整：比父节点大就交换位置（大根堆），重复调整直到不需要调整或者到根节点</li>
<li>从后往前，从上往下：对于堆数组从后往前遍历非叶子节点，每一次对比左右节点，然后调整：有一方比父节点大就交换位置（大根堆），重复调整直到不需要调整或到末尾节点</li>
</ul>
</li>
</ul>
<p>这两种创建方式的区别在于：一个是在新数组上创建堆，一个是在原来数组创建堆</p>
<p>参考：</p>
<ul>
<li><a href="https://visualgo.net/zh/heap">图形化堆</a></li>
<li><a href="https://www.cnblogs.com/oaoa/p/15024600.html">最小堆实现</a></li>
<li><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/60">前端进阶算法9：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li>
</ul>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组 children。</li>
<li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li>
</ul>
<p>要点：</p>
<ul>
<li>如果是哈希数组表示，children = [ ] 中，index 包含了字母的 ASCII 码信息，和一般的树节点有 val 不一样</li>
<li>叶子节点指向空节点，和一般树叶子节点值向 null 不一样</li>
</ul>
<p>参考：</p>
<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">力扣</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样才能做好面试，拿到心仪的offer</title>
    <url>/2022/04/18/%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E9%9D%A2%E8%AF%95%EF%BC%8C%E6%8B%BF%E5%88%B0%E5%BF%83%E4%BB%AA%E7%9A%84offer/</url>
    <content><![CDATA[<h2 id="怎样才能做好面试，拿到心仪的offer"><a href="#怎样才能做好面试，拿到心仪的offer" class="headerlink" title="怎样才能做好面试，拿到心仪的offer"></a>怎样才能做好面试，拿到心仪的offer</h2><blockquote>
<p>面试之路漫漫，也是一场提高自我的修行，切勿只重结果，为俗世迷了眼。</p>
</blockquote>
<p>废话不说，直上干货</p>
<h3 id="前人经验"><a href="#前人经验" class="headerlink" title="前人经验"></a>前人经验</h3><p><a href="https://www.cnblogs.com/lovesqcc/p/14354921.html">一位大龄程序员所经历的面试的历炼和思考</a></p>
<p><a href="https://segmentfault.com/a/1190000041375399">了解公司的提问套路</a></p>
<p><a href="https://jishuin.proginn.com/p/763bfbd6cdad">裸辞经验</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1745520">从 N 次失败中找到进入大厂的一些小招</a></p>
<p><a href="https://www.zhihu.com/question/37105493">程序员一年中最佳跳槽时间是什么时候？</a></p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ol>
<li>不会的问题不要强答，不会就说不会，答越多错越多</li>
<li>最好提前了解岗位信息</li>
<li>大公司提前看面经</li>
</ol>
<h3 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h3><ol>
<li><p>最大的优势是什么？</p>
<p>突出工作上的优势，尽量不是个人的自我满足</p>
<ul>
<li>owner意识高</li>
<li>做事比较严谨</li>
<li>项目把握度比较好</li>
<li>共赢的意识，帮助团队成功放在第一位</li>
</ul>
</li>
<li><p>技术上的优势？</p>
<ul>
<li>对于技术方面会在项目后有一定的思考总结</li>
<li>尝试重构自己的代码</li>
<li>对技术保持一定的专研</li>
</ul>
</li>
<li><p>你有什么要了解的？</p>
<ol>
<li>不能不问，因为这是个了解面试通过程度、未来团队、未来公司的方式。提供一些问题的思路：<ol>
<li>可以问下您对我的评价，以及有什么建议(希望找一个怎么样的前端)</li>
<li>团队氛围怎么样</li>
<li>项目技术栈如何</li>
</ol>
</li>
</ol>
</li>
<li><p>遇到过最大的挑战是什么</p>
<ul>
<li>模板：我（最近的一个时间）在做（怎样的一个产品／程序），这个产品／程序的目的是（帮助用户完成什么事），其中有一个（什么模块），为了实现（什么功能），用到了（什么技术），但是（遇到了什么挑战／难点／bug），我通过（怎样的手段）定位问题所在，问题出现的原因是（简要的点到技术点的描述），我在（至少两个资料来源）上找到了参考，最后基于（怎样的决策标准）决定采用（何种解决方法），运用了（哪种技术），最后成功解决了问题／实现了功能，结果是这个产品／程序（对用户，系统，性能，可用性，资源等产生了何种正面的影响）。下一步，我认为我应该研究（何种更先进的方式），进一步（怎样让产品／程序做得更好）。<br>参考：<a href="https://www.zhihu.com/question/35323603">https://www.zhihu.com/question/35323603</a></li>
</ul>
</li>
</ol>
<h3 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h3><ol>
<li>怎样体现技术深度？<ol>
<li>了解原理</li>
<li>知道关键</li>
<li>可以评价优劣</li>
</ol>
</li>
</ol>
<h3 id="怎么把项目展示好"><a href="#怎么把项目展示好" class="headerlink" title="怎么把项目展示好"></a>怎么把项目展示好</h3><ol>
<li><p>读懂面试官面试官想要考察什么。问项目经验，无非是考察下面几方面</p>
<ol>
<li>表达能力。面试者能不能在几分钟，把一个项目讲清楚。可以用start法则</li>
<li>实际工作经验。确认你承担的角色，核实技术细节</li>
<li>解决问题的能力。主要看你解决问题的思维，遇到问题，有没有挑战的勇气。</li>
<li>项目复盘总结的能力。那些比较成功，那些没有做好，有什么有继续优化的空间。</li>
</ol>
</li>
<li><p>掌握好正确的回答技巧</p>
<ol>
<li>回答不易太简单，也切勿长篇大论。遵循star法则：背景、目标、行动、结果</li>
<li>技术细节有的放矢。不要一次性过多的介绍技术细节，技术面点到为止，等面试官来问。因为面试官通常都有自己的面试节奏。</li>
<li>主动介绍项目亮点。因为面试官没有义务挖掘你的亮点，所以这就需要自己主动提。遇到不会的问题，就如实说这个技术点不会。或者半懂也可以直接说。甚至可以谈谈自己的见解。把自己了解的说说</li>
</ol>
</li>
<li><p>选择体现能力的项目：体现能力项目无非这么几种：</p>
<ul>
<li><p>大型工程项目，体现工程动手实践能力，工作中的项目一般比个人项目复杂的多，有不少人驾驭不了。</p>
</li>
<li><p>解决了技术难题的项目，工作中除了简单的业务代码之类的工作，也有不少难题，难题总是需要人解决，这更体现能力。</p>
</li>
<li><p>开创出自己的解决方案的项目，不少项目的开发都会有历史包袱，什么时候换，如何换新技术方案，才能最大提升团队的工作效率，这也是一个很重要很关键的地方。</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://juejin.cn/post/6846687596555272200">准备思路</a></p>
<p><a href="https://juejin.cn/post/7017732278509453348">正确介绍自己的项目经验</a></p>
<h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><h4 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h4><p><a href="https://juejin.cn/post/6990174096554360869#heading-6">字节跳动前端面经(已接offer~)</a></p>
<p><a href="https://juejin.cn/post/6990174096554360869#heading-6">两年字节面试</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>tree-shareking 是什么</title>
    <url>/2022/03/25/tree-shareking-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="tree-shareking-是什么"><a href="#tree-shareking-是什么" class="headerlink" title="tree-shareking 是什么"></a>tree-shareking 是什么</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tree-shaking 是 DCE（dead code elimination） 的一种新的实现</p>
<blockquote>
<p>DCE 就是消除死代码，死代码的特点：</p>
<ul>
<li>代码不会被执行，如return后的代码</li>
<li>代码执行，但不会被使用，如定义没使用的变量</li>
<li>代码被使用，但只影响死代码 ？</li>
</ul>
</blockquote>
<p>ree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注于消除没有用到的代码。</p>
<h2 id="tree-shareking原理"><a href="#tree-shareking原理" class="headerlink" title="tree-shareking原理"></a>tree-shareking原理</h2><p>利用ES6 模块的特点进行消除。因为ES6模块的依赖关系是确定的，可以进行可靠的静态分析。可以做到在打包阶段利用AST（抽象语法树）中删除死代码。</p>
<blockquote>
<p>静态分析：是指在不运行<a href="https://baike.baidu.com/item/代码/86048">代码</a>的方式下，通过<a href="https://baike.baidu.com/item/词法分析/8853461">词法分析</a>、<a href="https://baike.baidu.com/item/语法分析/8853407">语法分析</a>、<a href="https://baike.baidu.com/item/控制流/854473">控制流</a>、<a href="https://baike.baidu.com/item/数据流分析/21496987">数据流分析</a>等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。</p>
</blockquote>
<p>面向过程编程函数和面向对象编程是javascript最常用的编程模式和代码组织方式，可以通过webpack测试一下</p>
<p><strong>函数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220325-150304647.png" alt="图 7">  </p>
<p>预计del被消除，可以看到是没有了</p>
<p><strong>class类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220325-145806436.png" alt="图 6">  </p>
<p>del没有被消除，说明作为类，tree-shareking没有消除未使用的方法，不够彻底</p>
<p><a href="https://webpack.docschina.org/guides/tree-shaking/#add-a-utility">Webpack shaking</a></p>
<p><a href="https://juejin.cn/post/6844903544756109319">参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>前端模块化</title>
    <url>/2022/03/20/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="模块化的进程"><a href="#模块化的进程" class="headerlink" title="模块化的进程"></a>模块化的进程</h2><p><img src="https://cdn.jsdelivr.net/gh/adam-tan/markdown-image/img/IMG_20220320-165447497.png" alt="图 5">  </p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul>
<li>介绍：用于node服务端的模块引入，一般是同步的</li>
<li>基本语法<ul>
<li>导出：<code>module.exports = xxx</code>或者 <code>module.exports.x = xxx</code></li>
<li>引入：<code>var xxx = requrie(&#39;xx.js&#39;)</code></li>
</ul>
</li>
<li>特点<ul>
<li>引入的是对象的浅拷贝</li>
<li>作用域是在模块文件内部，不污染全局</li>
<li>可以多次加载，但是只运行一次</li>
<li>加载顺序，跟代码顺序一致</li>
</ul>
</li>
<li>应用场景<ul>
<li>服务器</li>
<li>浏览器需要借助Browserify</li>
</ul>
</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><ul>
<li><p>介绍：主要用于浏览器，比CommonJS在浏览器实现早，可以用require.js库，实现异步加载，底层是通过script节点插入脚本方式异步加载模块</p>
</li>
<li><p>基本语法</p>
<ul>
<li><p>导出</p>
<pre><code class="js">// 定义没有模块依赖的导出模块
define(function()&#123;
  // ...操作  
  var x = 1
  return 
&#125;)
// 定义有模块依赖的导出模块
define([m1,m2],function(m1,m2) &#123;
  // ...操作
  var x = 1
  return &#123;x&#125;
&#125;)</code></pre>
</li>
<li><p>引入</p>
<pre><code class="js">require([m1,m2], function() &#123;
  // ...操作 
&#125;)</code></pre>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>可以异步加载模块</li>
<li>依赖和引入以数组形式传入</li>
<li>回调形式执行加载后模块</li>
</ul>
</li>
</ul>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li><p>介绍：CommonJS和AMD的结合,也是通过script加载</p>
</li>
<li><p>导出：</p>
<pre><code class="js">// 定义没有模块依赖的导出模块
define(function(require, exports, module) &#123;
  exports.x = &#39;x&#39;
  // module.exports.x = &#39;x&#39;
  // return &#123;x&#125;
&#125;)
define(&#123; &quot;foo&quot;: &quot;bar&quot; &#125;) // JSON 数据模块
define(&#39;I am a template. My name is &#123;&#123;name&#125;&#125;.&#39;) // 字符串模板模块

// 定义有模块依赖的导出模块
define(&#39;id&#39;, [&#39;jquery&#39;], function(require, exports, module) &#123; 
  // 模块代码
&#125;)
</code></pre>
</li>
<li><p>引入</p>
<pre><code class="js">define(function(require, exports, module)&#123;
  //引入依赖模块(同步)
  var m1 = require(&#39;./m1&#39;)
  //引入依赖模块(异步)
    require.async(&#39;./m2&#39;, function (m2) &#123;
      // ···操作
    &#125;)
  //暴露模块
  exports.xxx = value
&#125;)</code></pre>
</li>
<li><p>应用</p>
<ul>
<li>浏览器，使用<a href="https://seajs.github.io/seajs/docs/">sea.js</a></li>
</ul>
</li>
</ul>
<h2 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h2><ul>
<li><p>介绍：ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。它设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
</li>
<li><p>导出</p>
<pre><code class="js">// 单个特性
export let a = 0, b = 1, c = 2
export function f() &#123;&#125;

// 列表
export &#123;a, b , c&#125;
export &#123;a as A&#125;

// 默认导出
export default let a = 0, b = 1
export default function f() &#123;&#125;

// 列表选择一个默认
export &#123;a as default ,...&#125;

// 导出模块合集
export * from …
export &#123; name1, name2, …, nameN &#125; from …
export &#123; default &#125; from …</code></pre>
</li>
<li><p>引入</p>
<pre><code class="js">// 默认导入
import defaultExport from &quot;module-name&quot;;
import * as name from &quot;module-name&quot;;

// 列表导入
import &#123; export &#125; from &quot;module-name&quot;;
import &#123; export as alias &#125; from &quot;module-name&quot;;
import &#123; export1 , export2 &#125; from &quot;module-name&quot;;</code></pre>
</li>
<li><p>特点：</p>
<ul>
<li><p>加载多次执行一次</p>
</li>
<li><p>动态引入，不是值的拷贝，模块的变量绑定其模块，即使导出也如此</p>
<pre><code class="javascript">/** import 动态引入 */
// lib.js
export let counter = 3;
export function incCounter() &#123;
  counter++;
&#125;
// main.js
import &#123; counter, incCounter &#125; from &#39;./lib&#39;;
console.log(counter); // 3
incCounter();
console.log(counter); // 4

/** CommonJS 类似于值的拷贝*/
var obj = &#123;
  add: function() &#123;
    this.val++
  &#125;,
  val: 0
&#125;
var &#123; val &#125; = obj
console.log(&#39;val-1&#39;, val++)
console.log(&#39;val-2&#39;, val++)
obj.add()
obj.add()
console.log(&#39;val-3&#39;, val) // 如果为动态引用此时输出应该为 4
// 输出
// val-1 0
// val-2 1
// val-3 2</code></pre>
</li>
</ul>
</li>
<li><p>与CommonJS差异</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>ES6 模块是编译时输出接口， CommonJS 模块是运行时加载</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>浏览器，可以用ES6-Babel和Browserify，实际上就是先转es5(但包含CommonJS语法)再用Browserify编译打包</li>
</ul>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000017466120#item-2-4">参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>js错误处理</title>
    <url>/2022/03/12/js%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="js错误处理"><a href="#js错误处理" class="headerlink" title="js错误处理"></a>js错误处理</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p>
<h2 id="一、try…catch的错误处理"><a href="#一、try…catch的错误处理" class="headerlink" title="一、try…catch的错误处理"></a>一、try…catch的错误处理</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code class="js">try &#123;

  // 代码1...

&#125; catch (err) &#123;

  // 错误捕获

&#125; finally &#123;

&#125;
// 代码2</code></pre>
<p>如果代码不出错，则执行完代码1后执行代码2，如果错误，则可以下catch中捕获，处理异常，然后继续执行代码2</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li><p>仅仅对运行时的error生效，代码语法错误是无法捕获的，如：</p>
<pre><code class="js">try &#123;</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>web性能监控</title>
    <url>/2022/03/11/web%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="web性能监控"><a href="#web性能监控" class="headerlink" title="web性能监控"></a>web性能监控</h1><h2 id="性能监控的指标"><a href="#性能监控的指标" class="headerlink" title="性能监控的指标"></a>性能监控的指标</h2><ul>
<li>页面访问速度<ul>
<li>首屏渲染 first paint (FP) 。ps: 白屏时间</li>
<li>首屏有内容渲染 first contentful paint (FCP)</li>
<li>可交互时长（到达可以交互的时长）</li>
</ul>
</li>
<li>页面稳定性<ul>
<li>js报错统计</li>
<li>资源加载错误统计</li>
</ul>
</li>
<li>外部服务调用<ul>
<li>CGI 耗时（公共网关接口）</li>
<li>CGI 成功率</li>
<li>CDN 资源耗时</li>
</ul>
</li>
</ul>
<p><a href="http://www.alloyteam.com/2020/01/14184/#prettyPhoto">参考</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="合成监控"><a href="#合成监控" class="headerlink" title="合成监控"></a>合成监控</h3><p>合成监控是采用 web 浏览器模拟器来加载网页，通过模拟终端用户可能的操作来采集对应的性能指标，最后输出一个网站性能报告。</p>
<ul>
<li>Lighthouse</li>
<li>PageSpeed</li>
<li>WebPageTest</li>
</ul>
<p>合成监控方式的优缺点：</p>
<ul>
<li>优点：<br>无侵入性。<br>简单快捷。</li>
<li>缺点：<br>不是真实的用户访问情况，只是模拟的。<br>没法考虑到登录的情况，对于需要登录的页面就无法监控到。</li>
</ul>
<h3 id="真实用户监控"><a href="#真实用户监控" class="headerlink" title="真实用户监控"></a>真实用户监控</h3><p>真实用户监控是一种被动监控技术，是一种应用服务，被监控的 web 应用通过 sdk 等方式接入该服务，将真实的用户访问、交互等性能指标数据收集上报、通过数据清洗加工后形成性能分析报表。例如 FrontJs、oneapm、Datadog 等。</p>
<ul>
<li>oneapm</li>
<li>Datadog</li>
</ul>
<p>优缺点</p>
<ul>
<li>优点：<br>是真实用户访问情况。<br>可以观察历史性能趋势。<br>有一些额外的功能：报表推送、监控告警等等。</li>
<li>缺点：<br>有侵入性，会一定程度上响应 web 性能。</li>
</ul>
<h3 id="前端实现方式"><a href="#前端实现方式" class="headerlink" title="前端实现方式"></a>前端实现方式</h3><ul>
<li>获取用户信息设备<ul>
<li>Navigator.userAgent</li>
</ul>
</li>
<li>获取性能数据<ul>
<li>插入script节点</li>
<li>H5 的 performance API</li>
</ul>
</li>
<li>获取首屏时间<ul>
<li>lighthouse 中使用的是 chrome 渲染过程</li>
<li>可利用 <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a> 拿到页面布局节点数目</li>
<li>MutationObserver</li>
</ul>
</li>
<li>异常上报<ul>
<li>js error： 监听 window.onerror 事件</li>
<li>promise reject 的异常： 监听 unhandledrejection 事件</li>
<li>资源加载失败：window.addEventListener(‘error’)</li>
<li>网络请求失败：重写 window.XMLHttpRequest 和 window.fetch</li>
<li>iframe异常：重写 window.frames[0].onerror</li>
<li>控制台报错：重写window.console.error</li>
</ul>
</li>
</ul>
<p><a href="https://juejin.cn/post/6950824230653001758#heading-3">前端实现方式</a></p>
<h2 id="微信小程序性能监控指标（待补充）"><a href="#微信小程序性能监控指标（待补充）" class="headerlink" title="微信小程序性能监控指标（待补充）"></a>微信小程序性能监控指标（待补充）</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/perf_data.html">参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>js 设计模式</title>
    <url>/2021/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="js-设计模式"><a href="#js-设计模式" class="headerlink" title="js 设计模式"></a>js 设计模式</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
</blockquote>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>实现图片预加载：在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性， 由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白，可以先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里：</p>
<p>不使用代理：</p>
<pre><code class="js">var MyImage = (function () &#123;
    var imgNode = document.createElement(&#39;img&#39;);
    document.body.appendChild(imgNode);
    var img = new Image();
    img.onload = function () &#123;
        imgNode.src = img.src;
    &#125;;
    return &#123;
        setSrc: function (src) &#123;
            imgNode.src = &#39;file:// /C:/Users/svenzeng/Desktop/loading.gif&#39;;
            img.src = src;
        &#125;,
    &#125;;
&#125;)();
MyImage.setSrc(&#39;http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&#39;);
</code></pre>
<p>使用代理</p>
<pre><code class="js">var myImage = (function () &#123;
  var imgNode = document.createElement(&#39;img&#39;); document.body.appendChild(imgNode);
  return &#123;
    setSrc: function (src) &#123;
      imgNode.src = src;
    &#125;
  &#125;
&#125;)();
var proxyImage = (function () &#123;
  var img = new Image; img.onload = function () &#123;
    myImage.setSrc(this.src);
  &#125;
  return &#123;
    setSrc: function (src) &#123;
      myImage.setSrc(&#39;file:// /C:/Users/svenzeng/Desktop/loading.gif&#39;);
      img.src = src;
    &#125;
  &#125;
&#125;)();
proxyImage.setSrc(&#39;http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&#39;);</code></pre>
<p>现在我们通过 proxyImage 间接地访问 MyImage。proxyImage 控制了客户对 MyImage 的访问，并 且在此过程中加入一些额外的操作，比如在真正的图片加载好之前，先把 img 节点的 src 设置为 一张本地的 loading 图片。</p>
<h3 id="代理的意义"><a href="#代理的意义" class="headerlink" title="代理的意义"></a>代理的意义</h3><p>维护单一职责</p>
<p>单一职责原则指的是，就一个类(通常也包括对象和函数等)而言，应该仅有一个引起它变 化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可 能会有多个。</p>
<p>面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多， 等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能 会遭到意外的破坏。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>迭代器模式是指提供一个方法可以顺序访问一个聚合对象的各个元素，而又不用暴露对象的内部表示。</p>
</blockquote>
<p>大部分语言都已经实现迭代器。在 js 比较有用的是提供访问类数组的方法：</p>
<pre><code class="js">// 在 JavaScript 中，for in 语句可以用来迭代普通字面量对象的属性。jQuery 中提供了$.each` 函数来封装各种迭代行为:
$.each = function (obj, callback) &#123;
  var value,
  i = 0,
  length = obj.length,
  isArray = isArraylike(obj);
  if (isArray) &#123; // 迭代类数组 for ( ; i &lt; length; i++ ) &#123;
    value = callback.call(obj[i], i, obj[i]);
    if (value === false) &#123;
      break;
    &#125;
  &#125;
&#125; else &#123;
  for (i in obj) &#123; // 迭代object对象
    value = callback.call(obj[i], i, obj[i]); if (value === false) &#123;
      break;
    &#125;
  &#125;
&#125;
return obj; &#125;;</code></pre>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p>
<p>扩展：</p>
<p><a href="https://zhuanlan.zhihu.com/p/60324936">实现一个 Event 类</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>redux生态库理解</title>
    <url>/2021/09/24/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3redux%E7%94%9F%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="redux生态库理解"><a href="#redux生态库理解" class="headerlink" title="redux生态库理解"></a>redux生态库理解</h1><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>状态管理库</p>
<ul>
<li>store：全局状态数据（一般是不可变的数据）</li>
<li>action：记录操作（type）和操作值（payload）的对象</li>
<li>reducer： 接收 state 和 action，并返回新的 state 的函数</li>
</ul>
<p>参考：<a href="https://www.redux.org.cn/docs/introduction/PriorArt.html">https://www.redux.org.cn/docs/introduction/PriorArt.html</a></p>
<h3 id="reselect"><a href="#reselect" class="headerlink" title="reselect"></a>reselect</h3><p>选择对应的部分store</p>
<h3 id="redux-sage"><a href="#redux-sage" class="headerlink" title="redux-sage"></a>redux-sage</h3><p>一个以redux中间件形式存在的库，更加优雅的管理异步操作（Side Effect：<strong>异步网络请求</strong>、<strong>本地读取 localStorage/Cookie</strong> 等外界操作）</p>
<p>通过createStore将store和sage关联起来</p>
<ul>
<li>Effect：一个简单的对象，这个对象包含了一些给 middleware 解释执行的信息。（调用某些异步函数，发起一个 action 到 store，等等）</li>
<li>put： 这个函数用于创建 dispatch Effect</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-9697122f53bb1c92a9c455c1b0e5d22f_r.jpg" alt="preview"></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/35437092">https://zhuanlan.zhihu.com/p/35437092</a></p>
<p>中文文档： <a href="https://redux-saga-in-chinese.js.org/">https://redux-saga-in-chinese.js.org/</a></p>
<h3 id="seamless-immutable"><a href="#seamless-immutable" class="headerlink" title="seamless-immutable"></a>seamless-immutable</h3><p>定义不可变的对象</p>
<p>每次修改都会返回一个新的对象</p>
<p>用树的方式存储数据，从而达到复用和高效更新</p>
<p>使用自带api操作数据，方法内置在prototype</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li>set(key, value) 设置值<ul>
<li>key: String</li>
<li>value: <any></li>
</ul>
</li>
<li>setIn([key, key2 … ], value) 设置嵌套对象里的值</li>
<li>get(key, value)</li>
<li>getIn([key, key2 …], value)</li>
<li>merge(obj || [obj, … ], config) 两个对象合并<ul>
<li>obj: Object</li>
<li>[obj, … ] : Array</li>
<li>config: Object 合并设置，比如: <code>&#123;deep: true&#125; // 深度合并</code></li>
</ul>
</li>
<li>isImmutable</li>
<li>asMutable</li>
<li>update(key, fn) 用函数操作更新<ul>
<li>key: String</li>
<li>fn: function 返回更新值value</li>
</ul>
</li>
<li>updateIn([key, key2 … ], fn) 用函数操作嵌套对象的更新</li>
</ul>
<p>github仓库：<a href="https://github.com/rtfeldman/seamless-immutable">https://github.com/rtfeldman/seamless-immutable</a></p>
<h3 id="redux-persist"><a href="#redux-persist" class="headerlink" title="redux-persist"></a>redux-persist</h3><h3 id="ramda"><a href="#ramda" class="headerlink" title="ramda"></a>ramda</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>移动端面试复习</title>
    <url>/2021/09/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="移动端面试复习"><a href="#移动端面试复习" class="headerlink" title="移动端面试复习"></a>移动端面试复习</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>最近在很多面试中都问到移动端的问题，暴露了我平时工作中对移动端经验不足的问题，但是天赋不够能力来凑，通过一些面试准备还是能够能混过关的，我希望在这里以问题为导向，探究下移动端的一些问题</p>
</blockquote>
<h2 id="一、移动端和pc端的区别"><a href="#一、移动端和pc端的区别" class="headerlink" title="一、移动端和pc端的区别"></a>一、移动端和pc端的区别</h2><ol>
<li>兼容性不同： pc向下考虑IE兼容，移动端更多考虑是手机兼容，如一些手机屏幕大小和分辨率的兼容</li>
<li>部分事件不同：移动端多出触屏事件，没有hover事件</li>
<li>部分场景不同：移动端手机软键盘</li>
<li>布局要求不同：移动端往往要求做到自适应</li>
<li>平台区别：移动端可能要依托小程序、微信公众号平台进行开发，pc端比较纯粹</li>
<li>性能要求不同：移动端对首屏加载速度，用户响应延迟、渲染性能、动画帧率要求比较高</li>
</ol>
<h2 id="二、点击穿透问题"><a href="#二、点击穿透问题" class="headerlink" title="二、点击穿透问题"></a>二、点击穿透问题</h2><p>  假如页面上有两个元素A和B。</p>
<p>  B元素在A元素之上。</p>
<p>  我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。</p>
<p>  我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p>
<p>  原因： 这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。</p>
<p>  解决方案：</p>
<ol>
<li>只用touch，简单完美</li>
<li>只用click，副作用大</li>
<li>tap后延迟350ms再隐藏mask</li>
<li>禁用缩放，不会有延迟</li>
<li>更改默认视窗宽度为自适应</li>
<li>引入插件，如：<a href="https://zhuanlan.zhihu.com/p/66845055">fastClick</a></li>
</ol>
<p><strong>移动端300ms点击延迟</strong>：</p>
<blockquote>
<p>移动端300ms点击延迟由来：</p>
<p>苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。</p>
<p>这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。</p>
</blockquote>
<p>如果只针对300ms点击延迟，有如下解决方案：</p>
<ol>
<li><p><strong>禁用缩放</strong></p>
<p>在meta加入以下信息，表明页面不可缩放，从而可以移动端浏览器自动禁掉默认300ms点击延迟</p>
<pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt;</code></pre>
<p><strong>缺点：</strong>完全禁用缩放影响用户体验</p>
</li>
<li><p><strong>更改默认的视口宽度</strong></p>
<p>一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，通常是设固定值980px。现在我们可以通过以下标签来设置视口宽度为设备宽度。</p>
<pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code></pre>
<p>如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述<code>meta</code>标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action">touch-action</a></p>
<p>CSS属性 <strong><code>touch-action</code></strong> 用于设置触摸屏用户如何操纵元素的区域(例如，浏览器内置的缩放功能)。</p>
<p>最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为（如地图或游戏表面）。如：</p>
<pre><code class="css">#map &#123;
  touch-action: none;
&#125;</code></pre>
</li>
</ol>
<p><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">参考</a></p>
<h2 id="三、移动端软键盘弹窗影响布局怎么解决"><a href="#三、移动端软键盘弹窗影响布局怎么解决" class="headerlink" title="三、移动端软键盘弹窗影响布局怎么解决"></a>三、移动端软键盘弹窗影响布局怎么解决</h2><ol>
<li><p>当在移动端按钮position:fixed;底部bottom:0;</p>
<p>固定在底部的按钮会被系统自带的键盘挤上去，占用输入框位置,如下</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdk62smds2j308r0fiab5.jpg" alt="preview" style="zoom:50%;" />

<p>解决：通过resize() 方法触发 resize 事件，当唤起键盘页面高度小于未唤起键盘页面高度时，取消fixed</p>
</li>
<li><p>安卓端，移动端页面输入底部被键盘遮挡问题</p>
<p>解决：</p>
<ul>
<li><p>通过 <code>window.onresize</code> 监听页面大小变化，然后通过 <code>window.scrollTo</code> 使页面滚动到所需位置</p>
</li>
<li><p>通过 <code>Element.scrollIntoView()</code></p>
</li>
<li><p>通过 <code>Element.scrollIntoViewIfNeeded()</code></p>
<p><a href="https://dclcats.github.io/2017/08/17/移动端页面输入底部被键盘遮挡问题/">参考</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/343569217">参考</a></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>js 布尔值转换和数据类型的简单判断</title>
    <url>/2021/07/03/js%20%E5%B8%83%E5%B0%94%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="js-布尔值转换和数据类型的简单判断"><a href="#js-布尔值转换和数据类型的简单判断" class="headerlink" title="js 布尔值转换和数据类型的简单判断"></a>js 布尔值转换和数据类型的简单判断</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>通常情况下js的布尔值转换和数据类型判断是一个比较容易犯错的问题，现在我们结合对照表来简单梳理一下</p>
</blockquote>
<h3 id="一、js-布尔值转换"><a href="#一、js-布尔值转换" class="headerlink" title="一、js 布尔值转换"></a>一、js 布尔值转换</h3><h4 id="一、-的情况下转换"><a href="#一、-的情况下转换" class="headerlink" title="一、==的情况下转换"></a>一、==的情况下转换</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">参考</a></p>
<h4 id="二、数据类型和布尔值的转换"><a href="#二、数据类型和布尔值的转换" class="headerlink" title="二、数据类型和布尔值的转换"></a>二、数据类型和布尔值的转换</h4><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">能转换为true</th>
<th align="center">能转化为false</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">ture</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">任何非空字符</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">number</td>
<td align="center">任何非零数字值</td>
<td align="center">0和NaN</td>
</tr>
<tr>
<td align="center">obj</td>
<td align="center">任何对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">—</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">arr</td>
<td align="center">任何数组</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h3 id="三、判断数据类型的方法"><a href="#三、判断数据类型的方法" class="headerlink" title="三、判断数据类型的方法"></a>三、判断数据类型的方法</h3><h4 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h4><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">typeof结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">string</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">number</td>
<td align="center">number</td>
</tr>
<tr>
<td align="center">booleam</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">undefind</td>
<td align="center">undefind</td>
</tr>
<tr>
<td align="center">functuon</td>
<td align="center">function</td>
</tr>
<tr>
<td align="center">obj</td>
<td align="center">obj</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">obj</td>
</tr>
<tr>
<td align="center">arr</td>
<td align="center">obj</td>
</tr>
</tbody></table>
<p>用法：</p>
<pre><code>typeof()  // 适合判断除null外的基本数据类型，不适合判断obj、arr、function等引用类型</code></pre><h4 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h4><p>用法:</p>
<pre><code>obj instanceof Object  // true
arr instanceof Array //true
pattern instanceof RegExp //true</code></pre><p> 注意事项以及适用范围：</p>
<ul>
<li>引用用类型所有值都是obj的事例，所以所以引用类型instanceof Object都为ture</li>
<li>可以判断是否为引用类型，或者是否为数组</li>
</ul>
<p>缺点：</p>
<p>instanceof会从原型链一直往上查找，假如有个obj的继承的原型是Array，此时<code>obj instanceof Array</code>为true，显示是错的</p>
<h4 id="3、toString方法"><a href="#3、toString方法" class="headerlink" title="3、toString方法"></a>3、toString方法</h4><p>用法</p>
<pre><code class="js">Object.prototype.toString.call([]) // [Object Array]</code></pre>
<p>判断数据类型最优的方法</p>
<h5 id="4、其他判断"><a href="#4、其他判断" class="headerlink" title="4、其他判断"></a>4、其他判断</h5><ul>
<li>Array.isArray 是否是数组</li>
<li>Number.isNaN 是否为NaN。tip：另外一个方法判断NaN，如果a=NaN 则 a !== ajic</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>怎样用js实现二叉树遍历</title>
    <url>/2021/03/04/%E6%80%8E%E6%A0%B7%E7%94%A8js%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote>
<p>二叉树是数据结构算法的重要知识点，今天我们用js来实现下二叉树的深度优先遍历</p>
</blockquote>
<p>首先，生成一个二叉树</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdtk9xb44qj30k80ia0tf.jpg" alt="Jietu20200414-201926@2x" style="zoom:50%;" />

<pre><code class="js">/*
二叉树
*/
var tree = &#123;
  value: 1,
  left: &#123;
    value: 2,
    left: &#123;
      value: 4
    &#125;
  &#125;,
  right: &#123;
    value: 3,
    left: &#123;
      value: 5,
      left: &#123;
        value: 7
      &#125;,
      right: &#123;
        value: 8
      &#125;
    &#125;,
    right: &#123;
      value: 6
    &#125;
  &#125;
&#125;</code></pre>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>递归</li>
</ul>
<pre><code class="js">function preOrder(node) &#123;
  if(node != null) &#123;
    console.log(node.value)
    preOrder(node.left)
    preOrder(node.right)
  &#125; 
&#125;</code></pre>
<ul>
<li>非递归</li>
</ul>
<pre><code class="js">
function preOrder(root) &#123;
  let stack = [];
  let pNode = root;
  while (pNode != null || !stack.length == 0) &#123;
   if (pNode != null) &#123;
    console.log(pNode.value+&quot;  &quot;);
    stack.push(pNode);
    pNode = pNode.left;
   &#125; else &#123; //pNode == null &amp;&amp; !stack.isEmpty()
    node = stack.pop();
    pNode = node.right;
   &#125;
  &#125;
 &#125;
preOrder(tree)

</code></pre>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>递归</li>
</ul>
<pre><code class="js">function preOrder(node) &#123;
  if(node != null) &#123;
    preOrder(node.left)
    console.log(node.value)
    preOrder(node.right)
  &#125; 
&#125;</code></pre>
<ul>
<li>非递归</li>
</ul>
<pre><code class="js">function midOrder(root) &#123;
  let stack = [];
  let pNode = root;
  while (pNode != null || !stack.length == 0) &#123;
   if (pNode != null) &#123;
    stack.push(pNode);
    pNode = pNode.left;
   &#125; else &#123; //pNode == null &amp;&amp; !stack.isEmpty()
    node = stack.pop();
        console.log(pNode.value+&quot;  &quot;);
    pNode = node.right;
   &#125;
  &#125;
 &#125;
midOrder(tree)</code></pre>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>递归</li>
</ul>
<pre><code class="js">function preOrder(node) &#123;
  if(node != null) &#123;
    preOrder(node.left)
    preOrder(node.right)
    console.log(node.value)
  &#125; 
&#125;</code></pre>
<ul>
<li>非递归</li>
</ul>
<pre><code class="js">

var lastOrder = (root) =&gt; &#123;
    let result = []
    let stack = []
    let node = root
    while(node != null || stack.length != 0)&#123;
        if(node != null) &#123;
            result.unshift(node.value)
            stack.push(node)
            node = node.right
        &#125;else&#123;
            node = stack.pop()
            //console.log(node.value)
            node = node.left
        &#125;
    &#125;
    return result

&#125;
lastOrder(tree)</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/09/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h3 id="一个表单验证的例子"><a href="#一个表单验证的例子" class="headerlink" title="一个表单验证的例子"></a>一个表单验证的例子</h3><p>给一个html页面，带一个form表单</p>
<pre><code class="html">&lt;form id=&#39;login-form&#39; action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;label for=&quot;account&quot;&gt;手机号&lt;/label&gt;
    &lt;input type=&quot;number&quot; id=&quot;account&quot; name=&quot;account&quot;&gt;
    &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;
    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;button id=&#39;login&#39;&gt;登录&lt;/button&gt;
&lt;/form&gt;</code></pre>
<h5 id="通常我们的做的简单表单验证"><a href="#通常我们的做的简单表单验证" class="headerlink" title="通常我们的做的简单表单验证"></a>通常我们的做的简单表单验证</h5><pre><code class="js">&lt;script&gt;
    var loginForm = document.getElementById(&#39;login-form&#39;);

    loginForm.onsubmit = function (e) &#123;
        e.preventDefault();  
        var account = document.getElementById(&quot;account&quot;).value;
        var pwd = document.getElementById(&quot;password&quot;).value;

        if(account===null||account===&#39;&#39;)&#123;
            alert(&#39;手机号不能为空&#39;)；
            return false;
        &#125;
        if(pwd===null||pwd===&#39;&#39;)&#123;
            alert(&#39;密码不能为空&#39;)；
            return false;
        &#125;
        if (!/(^1[3|4|5|7|8][0-9]&#123;9&#125;$)/.test(account)) &#123;
            alert(&#39;手机号格式错误&#39;)；
            return false;
        &#125;
        if(pwd.length&lt;6)&#123;
            alert(&#39;密码不能小于六位&#39;)；
            return false;
        &#125;
        // 发送请求
    &#125;
&lt;/script&gt;</code></pre>
<p>通常我们都是想，直接用if else来解决各种表单的验证，但是这样做的问题是，每次新加一个验证规则都要找到onsubmit函数，添加if判断，而且还要知道对应的字段名，麻烦就算了，最重要的是逻辑不能复用，如果有多个地方用到这个表单判断又要重写，这时候用到策略模式，一个策略就像一个诸葛亮的精囊妙计</p>
<h4 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h4><ul>
<li>意图： 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换</li>
<li>方式：创建一个策略对象和一个context，context的行为会随着不同的策略对象有不同的表现</li>
<li>解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</li>
</ul>
<h4 id="使用策略模式构建的表单校验"><a href="#使用策略模式构建的表单校验" class="headerlink" title="使用策略模式构建的表单校验"></a>使用策略模式构建的表单校验</h4><pre><code class="js">// 策略对象
const strategy = &#123;
    isNoEmpty: (val) =&gt; &#123;
        if(val === null || var == &#39;&#39;) &#123;
            return &#39;不能为空&#39;
        &#125;
    &#125;,
    isPhoneNum: (val) =&gt; &#123;
        if (!/(^1[3|4|5|7|8][0-9]&#123;9&#125;$)/.test(account)) &#123;
            return &#39;手机号格式错误&#39;
        &#125;
    &#125;,
    length: (val, len) =&gt; &#123;
        if (val.length &gt; len) &#123;
            return &#39;不能小于六位&#39;
        &#125;
    &#125;
 &#125;

// 上下文
const context = (formRule) =&gt; &#123;
    if(let i = 0; i &lt; formRule.length; i++) &#123;
        const item = formRule[i]
        const res = strategy[item.type](item.val)
        if(res) res
    &#125;
&#125;

/**
class validator &#123;
    constructor() &#123;
        this.strategy = null
        this.formRule =null 
    &#125;
    // 设置策略对象
    setStrategy(val) &#123;
        this.startegy = val
    &#125;
    // 设置规则
    setFormRule() &#123;
        this.formRule = val
    &#125;
    // 验证，相对于context
    validate() &#123;
        if(let i = 0; i &lt; formRule.length; i++) &#123;
        const item = formRule[i]
        const res = strategy[item.type](item.val)
        if(res) res
    &#125;
    &#125;
&#125;
*/

// 提交
function subimit() &#123;
    const form =  [
        &#123;type: &#39;isNoEmpty&#39;, val:account &#125;,
        &#123;type: &#39;isNoEmpty&#39;, val:pwd &#125;,
        &#123;type: &#39;isPhoneNum&#39;, val:account &#125;,
        &#123;type: &#39;length&#39;, val:pwd &#125;,
    ] // 简化的表单数据

    // 验证
    if(!context(form)) return

    /**
    // 验证
    const validator = new context()
    validator.setStrategy(strategy)
    validator.setFormrule(form)
    if(!validator.validate()) return
    */
    // 发起请求...

&#125;</code></pre>
<p>这里用的就是策略模式，定义了一个策略对象，和一个context控制执行，可以很方便的实现逻辑复用</p>
<h3 id="史诗级的表单验证"><a href="#史诗级的表单验证" class="headerlink" title="史诗级的表单验证"></a>史诗级的表单验证</h3><p>相关库 <a href="https://link.zhihu.com/?target=https%3A//github.com/yiminghe/async-validator">async-validator</a>，可以找相关源码了解，同样是用了了策略模式。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>把相互独立的代码块封装在一处，方便以后管理扩展</li>
<li>优于继承，继承的算法是封装在类里的，在算法多的情况下，会衍生很多不同的类，而类里面算法和使用者耦合也会增加维护难度</li>
<li>优化繁重的if else，提升代码简洁度</li>
</ol>
<p>缺点：</p>
<ol>
<li>选择算法时，必须了解全部算法的使用方法，才能选择合适的方法，违反最小知识原则</li>
<li>算法间相互独立，如果有共同部分无法实现共享</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>在哪些场景下适用，哪些场景不适用？</li>
<li>跟状态模式有什么不一样？</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>js常用算法面试题收集</title>
    <url>/2020/09/03/js%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="js常用算法面试题收集"><a href="#js常用算法面试题收集" class="headerlink" title="js常用算法面试题收集"></a>js常用算法面试题收集</h2><h4 id="1-统计一个字符出现的最高频率？"><a href="#1-统计一个字符出现的最高频率？" class="headerlink" title="1.统计一个字符出现的最高频率？"></a>1.统计一个字符出现的最高频率？</h4><pre><code class="js">let str = &#39;asdfghjklaqwertyuiopiaia&#39;;
function statistics(str)&#123;
  const strArr = [...str]
  let obj = &#123;&#125;
  // 统计字符数
  strArr.forEach((i) =&gt;&#123;
    obj[i] = obj[i] == undefined ? 0 :  ++obj[i]
  &#125;)
  // 求最大值
  return Object.keys(obj)
    .sort((i, r) =&gt; obj[r] - obj[i])[0] //降序排列
&#125;
console.log(statistics(str))    // a
</code></pre>
<h4 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2.数组去重"></a>2.数组去重</h4><ul>
<li>ruduce 方法</li>
</ul>
<pre><code class="js">let arr = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;1&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
function duplicate() &#123;
 return arr.reduce((r,v) =&gt; r.indexOf(v) &gt; -1 ? r : [...r, v], [])  
&#125;
console.log(duplicate())
</code></pre>
<ul>
<li>forEach</li>
</ul>
<pre><code class="js">let arr = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;1&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
const unique = arr =&gt; &#123;
    let obj = &#123;&#125;
    arr.forEach(value =&gt; &#123;
        obj[value] = 0
    &#125;)
    return Object.keys(obj)
&#125;
console.log(unique(arr))  // [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;a&#39;,&#39;b&#39;]</code></pre>
<ul>
<li>filter</li>
</ul>
<pre><code class="js">let arr = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;1&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
const unique = arr =&gt; &#123;
    return arr.filter((ele, index, array) =&gt; &#123;
        return index === array.indexOf(ele)
    &#125;)
&#125;
console.log(unique(arr))  // [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;a&#39;,&#39;b&#39;]</code></pre>
<ul>
<li>set</li>
</ul>
<pre><code class="js">let arr = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;1&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
const unique = arr =&gt; &#123;
    return new [...Set(arr)]
&#125;
console.log(unique(arr))  // [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;a&#39;,&#39;b&#39;]</code></pre>
<h4 id="3、翻转字符串"><a href="#3、翻转字符串" class="headerlink" title="3、翻转字符串"></a>3、翻转字符串</h4><pre><code class="js">let str = &#39;holle word&#39;
const reverseStr = str =&gt; &#123;
  return [...str].reverse().join(&#39;&#39;)
&#125;
console.log(reverseStr(str))</code></pre>
<h4 id="4、数组中最大差值"><a href="#4、数组中最大差值" class="headerlink" title="4、数组中最大差值"></a>4、数组中最大差值</h4><pre><code class="js">let arr = [2,44,22,8,9]
const different = arr =&gt; &#123;
  let sortArr = arr.sort((i,r) =&gt; i-r)
  return sortArr[sortArr.length - 1] - sortArr[0]
&#125;
console.log(different(arr))</code></pre>
<h4 id="5、不借助临时变量，进行两个整数的交换"><a href="#5、不借助临时变量，进行两个整数的交换" class="headerlink" title="5、不借助临时变量，进行两个整数的交换"></a>5、不借助临时变量，进行两个整数的交换</h4><ul>
<li>数组解构</li>
</ul>
<pre><code class="js">let a = 2,
    b = 3;
    [b,a] = [a,b]
    console.log(a,b)   // 3 2</code></pre>
<ul>
<li>算术运算（加减）</li>
</ul>
<pre><code class="js">let a = 2,
    b = 3;
const swop = (a, b) =&gt; &#123;
    b = b - a;
    a = a + b;
    b = a - b;
    return [a,b];
&#125;
console.log(swop(2,3)) // [3,2]</code></pre>
<h4 id="6、冒泡排序"><a href="#6、冒泡排序" class="headerlink" title="6、冒泡排序"></a>6、冒泡排序</h4><pre><code class="js">let arr = [43, 32, 1, 5, 9, 22];
const sort = arr =&gt; &#123;
    arr.forEach((v, i) =&gt; &#123;
        for (let j = i + 1; j &lt; arr.length; j++) &#123;
            if (arr[i] &gt; arr[j]) &#123;
                [arr[i],arr[j]] = [arr[j],arr[i]]
            &#125;
            console.log(arr)
        &#125;
    &#125;)
    return arr
&#125;
console.log(sort([43, 9, 5, 22, 32, 1]))  // [1, 5, 9, 22, 32, 43]</code></pre>
<h4 id="7、分割数组"><a href="#7、分割数组" class="headerlink" title="7、分割数组"></a>7、分割数组</h4><p>题目：给一个形如<code>[&#39;&#39;, 1, 2, &#39;&#39;, &#39;&#39;, 6, 7, 8]</code>的数组，里面需要分割成<code>[[1,2], [6,7,8]]</code>的形式</p>
<pre><code class="js">// 分割&#39; &#39;,双指针法
function separate(arr) &#123;
  let pre = 0 //前节点
  let cur = 0 // 当前节点
  let res = []
  let _arr = [...arr.slice(0), &#39;&#39;] //加入一个&#39;&#39;,作为结尾，兼容结尾为数字的情况

  while(cur &lt; _arr.length) &#123;
    // 前后节点一致的情况，遇到&#39;&#39;跳过
    if(_arr[pre] === &#39;&#39; &amp;&amp; _arr[cur] === &#39;&#39;) &#123; 
      pre++
      cur++
      continue
    &#125;
  // 前后节点不一致的情况一，都不为空串，只移动cur，相当于记录pre
    if(_arr[pre] !== &#39;&#39; &amp;&amp; _arr[cur] !== &#39;&#39;) &#123;
      cur++
      continue
    &#125;
    // 前后节点不一致的情况二，cur遇到空串，表示到了分割点，加入区间[)到数组
    if(_arr[pre] !== &#39;&#39; &amp;&amp; _arr[cur] === &quot;&quot;) &#123;
      res.push(_arr.slice(pre, cur))
      cur++
      pre = cur
    &#125;
  &#125;

  return res
&#125;

console.log(separate([&#39;&#39;, 1, 2, &#39;&#39;, &#39;&#39;, 6, 7, 8]))
console.log(separate([0, 1, 2, &#39;&#39;, &#39;&#39;, 6, 7, &#39;&#39;]))</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/08/15/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre><code class="js">function sort(nums, l, r) &#123;
   if(r - l &lt;= 0) return
   let pivot = partition1(nums, l, r)
   console.log(&#39;pivot&#39;, pivot)
   // left
   sort(nums, l, pivot -1)
   // right
   sort(nums, pivot + 1, r)
   return nums
&#125;

function partition(nums,l,r) &#123;
   // 中心位置
   let center = l
   // 指针
   let compare = r
   while(center != compare) &#123;
       // 在右边移动指针时
       if(center &lt; compare) &#123;
          if(nums[center] &gt; nums[compare]) &#123;
             let temp = nums[center]
             nums[center] = nums[compare]
             nums[compare] = temp
             let num = compare
             compare = center
             center = num
             compare++
             continue
          &#125;
          compare--
       &#125;
       // 在左边移动指针时
       else &#123;
           if(nums[center] &lt; nums[compare]) &#123;
              let temp = nums[center]
              nums[center] = nums[compare]
              nums[compare] = temp
              let num = compare
              compare = center
              center = num
              compare--
              continue
          &#125;
          compare++    
       &#125;
   &#125;
   console.log(nums)
   return center
 &#125;

 function partition1 (nums,l,r) &#123;
    // 保存基准值
    let pivot = nums[l]
    while(l!=r) &#123;
       while(r &gt; l &amp;&amp; nums[r] &gt;= pivot) &#123;
         r--
       &#125;
       nums[l] = nums[r]
       while(r &gt; l &amp;&amp; nums[l] &lt;= pivot) &#123;
         l++
       &#125;
       nums[r] = nums[l]
    &#125;
    nums[l] = pivot
    return l
 &#125;

 console.log(sort([45,23,55,12,4,88,1,2,4], 0, 8))</code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre><code class="js">function sort(nums) &#123;
   for(let i = 0; i &lt; nums.length; i++) &#123;
      // 插入的数
      let insert = nums[i]
      //j 为排序列表长度
      let j = i -1
      for(j ; j &gt;= 0; j--) &#123;
         if(insert &lt; nums[j]) &#123;
            // insert往前挪
            nums[j + 1] = nums[j]
            nums[j] = insert
         &#125;
      &#125;
   &#125;
   return nums
&#125;

function sort2(nums) &#123;
   for(let i = 0; i &lt; nums.length; i++) &#123;
      // 插入的数
      let insert = nums[i]
      //j 为已排序列表长度
      let j = i -1
      while(j&gt;= 0 &amp;&amp; insert &lt; nums[j]) &#123;
            nums[j + 1] = nums[j]
            j--z
      &#125;
      nums[j + 1] = insert
   &#125;
   return nums
&#125;




 console.log(sort([45,23,55,12,4,88,1,2,4]))


</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript</title>
    <url>/2020/08/03/typescript/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本篇文章主要是为了给让大家了解下Typescript</p>
<p>这里将会讲到大家关心的几个问题，简单先简绍了几个与js不同的ts的语法，来探讨ts和传统js的区别</p>
<p>然后从网络上收集整理了一些使用和不使用ts的意见，探讨我们应不应该使用ts，以及ts的适用场景</p>
<p>@[TOC]  </p>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>JavaScript 的超集</li>
<li>增加了静态类型系统</li>
<li>为大型软件开发而设计的</li>
<li>最终编译产生 JavaScript</li>
</ul>
<h4 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h4><p>执行<code>npm install -g typescript</code></p>
<p>然后就可以在任何地方编译ts文件<code>tsc holle.ts</code></p>
<h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><p>将下面代码复制到<code>hello.ts</code>中, 其中使用 : 指定变量的类型</p>
<pre><code class="javascript">function sayHello(person: string) &#123;
    return &#39;Hello, &#39; + person;
&#125;

let user = &#39;Tom&#39;;
console.log(sayHello(user));
</code></pre>
<p>然后执行</p>
<p><code>tsc holle.ts</code>、</p>
<p>这时候会生成一个编译好的文件<code>hello.js</code>：</p>
<pre><code class="javascript">function sayHello(person) &#123;
    return &#39;Hello, &#39; + person;
&#125;
var user = &#39;Tom&#39;;
console.log(sayHello(user));</code></pre>
<h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p>编译下段代码</p>
<pre><code class="javascript">// holle.ts
function sayHello(person: string) &#123;
    return &#39;Hello, &#39; + person;
&#125;

let user = [0, 1, 2];
console.log(sayHello(user));</code></pre>
<p>编译器报错</p>
<pre><code class="javascript">index.ts(6,22): error TS2345: Argument of type &#39;number[]&#39; is not assignable to parameter of type &#39;string&#39;.</code></pre>
<p><strong>因为TypeScript 编译的时候会进行静态检查，如果发现有错误，就会报错</strong></p>
<p>但注意，即使报错，也会生成相应的js文件</p>
<h3 id="二、与js异同"><a href="#二、与js异同" class="headerlink" title="二、与js异同"></a>二、与js异同</h3><h4 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h4><p>和es6一样，有let和const</p>
<h4 id="2、基础数据类型"><a href="#2、基础数据类型" class="headerlink" title="2、基础数据类型"></a>2、基础数据类型</h4><p>bool、number、string、undefined、arr、obj都有<br>不同的：</p>
<ul>
<li>元组</li>
</ul>
<blockquote>
<p>允许表示一个已知元素数量和类型的数组</p>
</blockquote>
<pre><code class="javascript">// Declare a tuple type
let x: [string, number];
// Initialize it
x = [&#39;hello&#39;, 10]; // OK</code></pre>
<ul>
<li>枚举</li>
</ul>
<blockquote>
<p>像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
</blockquote>
<pre><code class="javascript">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;</code></pre>
<ul>
<li>Any</li>
</ul>
<pre><code class="javascript">let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean</code></pre>
<blockquote>
<p>还不清楚类型的变量指定一个类型</p>
</blockquote>
<ul>
<li>Void</li>
</ul>
<blockquote>
<p>void类型像是与any类型相反，它表示没有任何类型。</p>
</blockquote>
<pre><code class="javascript">function warnUser(): void &#123;
    console.log(&quot;This is my warning message&quot;);
&#125;</code></pre>
<ul>
<li>never</li>
</ul>
<blockquote>
<p>表示的是那些永不存在的值的类型。</p>
</blockquote>
<pre><code class="javascript">// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;

// 推断的返回值类型为never
function fail() &#123;
    return error(&quot;Something failed&quot;);
&#125;

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never &#123;
    while (true) &#123;
    &#125;
&#125;</code></pre>
<ul>
<li>类型断言</li>
</ul>
<blockquote>
<p>&lt; &gt;表示， 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
</blockquote>
<pre><code class="javascript">et someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;</code></pre>
<ul>
<li>多种类型(联合类型)</li>
</ul>
<blockquote>
<p>可以用|隔开，比如number | string表示可以是number或string类型</p>
</blockquote>
<h4 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h4><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<ul>
<li>简单的接口</li>
</ul>
<blockquote>
<p>定义传入的参数</p>
</blockquote>
<pre><code class="javascript">interface LabelledValue &#123;
  label: string;
&#125;

function printLabel(labelledObj: LabelledValue) &#123;
  console.log(labelledObj.label);
&#125;

let myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;
printLabel(myObj);</code></pre>
<ul>
<li>可选接口</li>
</ul>
<blockquote>
<p>参数可选</p>
</blockquote>
<pre><code class="javascript"> interface SquareConfig &#123;
  color?: string;
  width?: number;
&#125;</code></pre>
<ul>
<li>只读属性</li>
</ul>
<blockquote>
<p>传入参数只读</p>
</blockquote>
<pre><code class="javascript">interface Point &#123;
    readonly x: number;
    readonly y: number;
&#125;

let p1: Point = &#123; x: 10, y: 20 &#125;;
p1.x = 5; // error!</code></pre>
<ul>
<li>描述函数</li>
</ul>
<blockquote>
<p>定义函数输入输出</p>
</blockquote>
<pre><code class="javascript">interface SearchFunc &#123;
  (source: string, subString: string): boolean;
&#125;

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) &#123;
  let result = source.search(subString);
  return result &gt; -1;
&#125;</code></pre>
<ul>
<li>实现接口</li>
</ul>
<blockquote>
<p>在类中实现接口</p>
</blockquote>
<pre><code class="javascript">interface ClockInterface &#123;
    currentTime: Date;
    setTime(d: Date);
&#125;

class Clock implements ClockInterface &#123;
    currentTime: Date;
    setTime(d: Date) &#123;
        this.currentTime = d;
    &#125;
    constructor(h: number, m: number) &#123; &#125;
&#125;</code></pre>
<ul>
<li>继承接口</li>
</ul>
<pre><code class="javascript">interface Shape &#123;
    color: string;
&#125;

interface PenStroke &#123;
    penWidth: number;
&#125;

interface Square extends Shape, PenStroke &#123;
    sideLength: number;
&#125;

let square = &lt;Square&gt;&#123;&#125;;
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;</code></pre>
<h4 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. 类</h4><p>定义了一件事物的抽象特点，包含它的属性和方法</p>
<p>面向对象（OOP）的三大特性：封装、继承、多态</p>
<p>对象实例通过new生成</p>
<ul>
<li>封装</li>
</ul>
<blockquote>
<p>将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</p>
</blockquote>
<ul>
<li>多态</li>
</ul>
<blockquote>
<p>由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat</p>
</blockquote>
<ul>
<li>继承</li>
</ul>
<blockquote>
<p>子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</p>
</blockquote>
<pre><code>class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();</code></pre><ul>
<li>存取器（getter &amp; setter)</li>
</ul>
<blockquote>
<p>用以改变属性的读取和赋值行为</p>
</blockquote>
<ul>
<li>修饰符（Modifiers)</li>
</ul>
<blockquote>
<p>修饰符是一些关键字，用于限定成员或类型的性质。如  public 和 private</p>
</blockquote>
<ul>
<li>抽象类（Abstract Class）</li>
</ul>
<blockquote>
<p>抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现<br>这个和接口有点像，有兴趣可以看下<a href="https://www.jianshu.com/p/038f0b356e9a">接口和抽象类的区别</a></p>
</blockquote>
<h4 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5. 泛型"></a>5. 泛型</h4><p>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。</p>
<pre><code class="javascript">// 使用泛型前
function identity(arg: number): number &#123;
    return arg;
&#125;
// 使用泛型后
function identity&lt;T&gt;(arg: T): T &#123;
    return arg;
&#125;</code></pre>
<p>T帮助我们捕获用户传入的类型，使用后再返回类型T的值</p>
<h4 id="6-使用第三方模块"><a href="#6-使用第三方模块" class="headerlink" title="6.使用第三方模块"></a>6.使用第三方模块</h4><ul>
<li>需要相应的声明文件（.d.ts文件）</li>
</ul>
<blockquote>
<p>一般情况下在 TypeScript 中是不能”直接“使用 npm 上的模块</p>
</blockquote>
<blockquote>
<p>不是使用 TypeScript 编写的模块，也可以通过手动编写声明文件来兼容 TypeScript。</p>
</blockquote>
<ul>
<li>通过 npm install @types/xxx 来安装模块声明文件</li>
</ul>
<blockquote>
<p>TypeScript 官方建立了一个名叫 DefinitelyTyped 的仓库，任何人都可以通过 GitHub 在上面修改或者新增 npm 模块的声明文件</p>
</blockquote>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>还有其他类型就不一一详细介绍了，具体可以参照<a href="https://www.tslang.cn/docs/home.html">官方文档(中文版)</a></p>
<h3 id="三、使用与不使用的理由"><a href="#三、使用与不使用的理由" class="headerlink" title="三、使用与不使用的理由"></a>三、使用与不使用的理由</h3><h4 id="1-不使用的理由"><a href="#1-不使用的理由" class="headerlink" title="1. 不使用的理由"></a>1. 不使用的理由</h4><ul>
<li>npm装上的那些xxxjs库都是没有任何类型信息的</li>
</ul>
<blockquote>
<p>（只能使用诸如definitelytyped之类的ts定义库）</p>
</blockquote>
<ul>
<li>TS+框架会有很多坑</li>
</ul>
<blockquote>
<ul>
<li>比如 ：immutable.js + Typescript 坑很多</li>
<li>必须学习框架+全家桶的各种暴露出来的d.ts</li>
<li>TS彻底替代babel会出问题,比如不能享受babel-plugin-import这种按需引入的Babel插件了</li>
</ul>
</blockquote>
<ul>
<li>虽然声称可以在任何场景下替代JS，但前提是有良好的框架支撑</li>
</ul>
<blockquote>
<ul>
<li>vue2.5以前对TS的支持不是特别好，但Vue本身支持不错,周边那些东西缺没那么好 GitHub： 2K</li>
<li>react 和 Angular 本身和周边支持良好 ，GitHub： 11K 和 10K</li>
</ul>
</blockquote>
<ul>
<li>语法检测和ESlint部分重复</li>
</ul>
<p>总结，项目不大，后期不用维护的项目没有必要使用，项目主要依赖库要对TS支持良好，冷门的小项目没有必要用TS</p>
<h4 id="2-使用的理由"><a href="#2-使用的理由" class="headerlink" title="2. 使用的理由"></a>2. 使用的理由</h4><ul>
<li><p>侦测错误，提供了一套强类型的规范，统一团队代码风格，更方便准确地检查错误</p>
</li>
<li><p>在项目初期就进行，类型注释，和接口定义，方便指导开发，</p>
</li>
<li><p>文档，新人来了也可以直接看文档接手项目</p>
</li>
</ul>
<blockquote>
<p>抽象，前端圈子里有这么一个流行语『自从用了Typescript之后,再也不想用JavaScript了』</p>
</blockquote>
<ul>
<li><p>静态类型语言，在编译的时候就能发现问题</p>
</li>
<li><p>方便代码重构</p>
</li>
</ul>
<blockquote>
<p>比如初期定义了一个string，但项目进行到一半说要改成number，如果普通的js，改一个不会报错，eslint则不会识别没有执行到文件的类型错误，而在TS强类型在编译器检验下，在编译时进行类型分析，改一个，其他需要改动的地方无可型盾</p>
</blockquote>
<ul>
<li>antd使用的是TS</li>
</ul>
<p>总结，这些特点还是挺诱人的，大型项目可以使用，总体来说，学习成本有，但熟悉过es6的人来说，门槛不算太高，比较类似java的风格。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/103933b7c2b4">Typescript基础入门</a></li>
<li><a href="https://juejin.im/post/59c46bc86fb9a00a4636f939">Tyepscript体系调研报告</a></li>
<li><a href="http://taobaofed.org/blog/2017/03/09/head-first-typescript/">认识 TypeScript</a></li>
</ul>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>注释规范初稿</title>
    <url>/2020/06/14/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h1 id="注释规范初稿"><a href="#注释规范初稿" class="headerlink" title="注释规范初稿"></a>注释规范初稿</h1><ul>
<li><p><strong>强制</strong>  </p>
<ol>
<li><p>方法的注释必须使用 JsDoc 规范，使用/<em>*内容</em>/格式，不得使用 // xxx方式。</p>
</li>
<li><p>所有的公用方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
</li>
<li><p>所有的公用方法都必须添加创建者和创建日期</p>
</li>
<li><p>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释<br>使用/**/注释，注意与代码对齐。  </p>
</li>
</ol>
</li>
<li><p><strong>推荐</strong>  </p>
<ol start="5">
<li>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。</li>
</ol>
<blockquote>
<p>反例:“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。  </p>
</blockquote>
<ol start="6">
<li>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。</li>
</ol>
<blockquote>
<p>说明:代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。  </p>
</blockquote>
<ol start="7">
<li><p>对于注释的要求:第一、能够准确反应设计思想和代码逻辑;第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。  </p>
<blockquote>
<p>完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
</blockquote>
</li>
<li><p>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的<br>一个极端:过多过滥的注释</p>
</li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/han-1034683568/p/7680354.html">阿里巴巴java开发手册</a></p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
  </entry>
  <entry>
    <title>API规范</title>
    <url>/2020/04/03/API%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h1 id="API规范"><a href="#API规范" class="headerlink" title="API规范"></a>API规范</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>RESTful API是目前比较成熟的一套互联网应用程序的API设计理论,它遵循资源导向的设计方式。<br>它有三个主要要素：资源，集合和 URLs。</p>
<ul>
<li>资源具有数据，嵌套，和一些操作方法。  </li>
<li>一组资源称为一个集合。  </li>
<li>URL标识资源或集合的线上位置。  </li>
</ul>
</li>
</ul>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul>
<li>使用kebab-case（短横线分割）的URL</li>
</ul>
<blockquote>
<p>例子：<code>/api/be/project-config</code></p>
</blockquote>
<ul>
<li>在查询字符串或资源字段中使用camelCase模式。</li>
</ul>
<blockquote>
<p>例子：<code>/api/be/meeting-config/projectUid=1453</code></p>
</blockquote>
<ul>
<li>URLs里面请尽量少用动词</li>
</ul>
<blockquote>
<p>因为如果您为每个资源操作使用一个动词，您很快就会维护一个很大的URL列表，而且没有一致的使用模式，这会使开发人员难以学习。此外，我们还要使用动词做别的事情。<br>错误例子：<code>/api/be/project-config/create/list</code><br><code>/api/be/project-config/users/addName</code></p>
</blockquote>
<ul>
<li>为非资源型请求使用动词。在这种情况下，您的API并不需要返回任何资源。而是去执行一个操作(除CRUD操作）并返回执行结果。</li>
</ul>
<blockquote>
<p>例子：<code>/api.github.com/_private/browser/star</code>  点赞操作</p>
</blockquote>
<ul>
<li>资源命名区分单复数<blockquote>
<p>文档(Document)类型的资源用名词(短语)单数命名（<em>如一篇文章<code>https://api/article</code></em>）<br>集合(Collection)类型的资源用名词(短语)复数命名（<em>如文章列表<code>https://api/articles</code></em>）</p>
</blockquote>
</li>
</ul>
<h4 id="操作表示"><a href="#操作表示" class="headerlink" title="操作表示"></a>操作表示</h4><ul>
<li><p>HTTP方法来操作CRUD功能</p>
<blockquote>
</blockquote>
<p>GET:       查询—–查询资源<br>POST:     创建—-创建一些新的资源或者子资源<br>PUT:      更新全部—-更新一个存在的资源（提供全部信息）<br>PATCH:    更新部分—-更新现有资源。它只更新所提供的字段，不管其他字段<br>DELETE:   删除—–删除一个存在的资源</p>
<p>例子：</p>
<blockquote>
<p> GET /zoos：列出所有动物园<br>POST /zoos：新建一个动物园<br>GET /zoos/ID：获取某个指定动物园的信息<br>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）<br>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>DELETE /zoos/ID：删除某个动物园<br>GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物  </p>
</blockquote>
<p>附：<a href="https://segmentfault.com/q/1010000005685904">pacth与put的区别</a></p>
</li>
<li><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<blockquote>
<p><code>?limit=10</code>：指定返回记录的数量<br><code>?offset=10</code>：指定返回记录的开始位置。<br><code>?page=2&amp;per_page=100</code>：指定第几页，以及每页的记录数。<br><code>?sortby=name&amp;order=asc</code>：指定返回结果按照哪个属性排序，以及排序顺序。<br><code>?producy_type=1</code>：指定筛选条件</p>
</blockquote>
</li>
</ul>
<p>​ </p>
<h4 id="关系表示"><a href="#关系表示" class="headerlink" title="关系表示"></a>关系表示</h4><ul>
<li><p>对于嵌套资源，在URL体现关系。  同时避免层级过深。<br>例如，使用id将员工与公司联系起来。  </p>
<blockquote>
<p><code>GET /schools/2/students</code> , 应该从学校2得到所有学生的名单<br><code>GET /schools/2/students/31</code> , 应该得到学生31的详细信息，且此学生属于学校2<br><code>DELETE /schools/2/students/31</code> , 应删除属于学校2的学生31<br><code>PUT /schools/2/students/31</code>, 应该更新学生31的信息<br><code>POST /schools</code> , 应该创建一所新学校，并返回创建的新学校的细节。在集合URL上使用POST  </p>
</blockquote>
<p>但是如 <code>GET /zoos/1/areas/3/animals/4</code><br>尽量使用查询参数代替路径中的实体导航，如<code>GET/animals?zoo=1&amp;area=3</code></p>
<p>附：<a href="https://blog.csdn.net/xcc_2269861428/article/details/80433382">post请求和get请求的区别</a>  </p>
</li>
<li><p>如有迭代版本（v1,v2,v3），使用简单的序数表示版本。并将其移到URL的左侧，使其具有最高的范围表述：</p>
<blockquote>
<p><code>http://api.domain.com/v1/schools/3/students</code></p>
</blockquote>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>Response不要包装，body 直接就是数据，</p>
<blockquote>
<p>错误例子：<code>&#123;
 &quot;success&quot;:true，
 &quot;data&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;xiaotuan&quot;&#125;,
&#125;</code></p>
</blockquote>
</li>
<li><p>Service/DAO层方法命名规约</p>
<blockquote>
<p>   1) 获取单个对象的方法用get做前缀。<br>   2) 获取多个对象的方法用list做前缀。<br>   3) 获取统计值的方法用count做前缀。<br>   4) 插入的方法用save/insert做前缀。<br>   5) 删除的方法用remove/delete做前缀。<br>   6) 修改的方法用update做前缀。</p>
</blockquote>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="http://wangwei.info/about-rest-api/">REST接口设计规范</a></li>
<li><a href="https://gumutianqi1.gitbooks.io/specification-doc/content/specification-doc/restful_api.html">API接口规范</a></li>
<li><a href="https://github.com/elsewhencode/project-guidelines">A set of best practices for JavaScript projects</a></li>
</ul>
<h3 id="github网站页面的部分API参考"><a href="#github网站页面的部分API参考" class="headerlink" title="github网站页面的部分API参考"></a>github网站页面的部分API参考</h3><blockquote>
<p><a href="https://github.com/ant-design/ant-design">https://github.com/ant-design/ant-design</a></p>
</blockquote>
<ul>
<li><p>请求star数量 <code>https://api.github.com/_private/browser/stats</code>  </p>
</li>
<li><p>用户资料卡 <code>https://github.com/hovercards?user_id=7264444&amp;subject=33</code>  </p>
</li>
<li><p>star <code>https://github.com/ant-design/ant-design/star</code>  </p>
</li>
<li><p>unstar <code>https://github.com/ant-design/ant-design/unstar</code></p>
</li>
<li><p>Issues功能  <code>https://github.com/ant-design/ant-design/issues?_pjax=%23js-repo-pjax-container</code></p>
</li>
<li><p>查询功能 <code>https://github.com/ant-design/ant-design/search/count?q=d%27d%27d&amp;type=Commits&amp;unscoped_q=d%27d%27d</code></p>
</li>
<li><p>更新设置 <code>https://github.com/newsletter_preference</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo使用</title>
    <url>/2020/04/03/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><p>参考 <a href="https://blog.ctftools.com/2021/07/newpost-18/#3-3-%E5%8F%91%E5%B8%83%E5%88%B0-github-pages">https://blog.ctftools.com/2021/07/newpost-18/#3-3-%E5%8F%91%E5%B8%83%E5%88%B0-github-pages</a></p>
]]></content>
  </entry>
  <entry>
    <title>AMD、CMD、CommonJS以及UMD的简单对比</title>
    <url>/2020/03/02/AMD%E3%80%81CMD%E3%80%81CommonJS%E4%BB%A5%E5%8F%8AUMD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="AMD、CMD、CommonJS以及UMD的简单对比"><a href="#AMD、CMD、CommonJS以及UMD的简单对比" class="headerlink" title="AMD、CMD、CommonJS以及UMD的简单对比"></a>AMD、CMD、CommonJS以及UMD的简单对比</h1><h3 id="一、AMD"><a href="#一、AMD" class="headerlink" title="一、AMD"></a>一、AMD</h3><p>为浏览器环境设计的， 所以是异步模块加载定义的</p>
<ul>
<li>加载模块</li>
</ul>
<p>AMD采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<pre><code class="js"> 　　require([module], callback);</code></pre>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。</p>
<ul>
<li>定义模块</li>
</ul>
<p>模块通过 <code>define</code> 函数定义在闭包中，格式如下：</p>
<pre><code class="js">define(id?: String, dependencies?: String[], factory: Function|Object)</code></pre>
<p><code>id</code> 是模块的名字，它是可选的参数。</p>
<p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 <code>factory</code> 中。如果没有指定 <code>dependencies</code>，那么它的默认值是 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code>。</p>
<p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p>
<p>用例：</p>
<p>定义一个名为 <code>myModule</code> 的模块，它依赖 <code>jQuery</code> 模块：</p>
<pre><code class="js">define(&#39;myModule&#39;, [&#39;jquery&#39;], function($) &#123;
    // $ 是 jquery 模块的输出
    $(&#39;body&#39;).text(&#39;hello world&#39;);
&#125;);
// 使用
require([&#39;myModule&#39;], function(myModule) &#123;&#125;);</code></pre>
<p>二、CMD</p>
<p>和AMD同样是异步加载</p>
<ul>
<li><p>加载模块</p>
<p>分为三种：</p>
<p>requirea(name)；name为模块名</p>
<p>require.async(name, callback)；异步加载 ，callback为加载后执行函数</p>
<p>require.resolve(name);不加载模块，仅仅将短串解析成完整路径</p>
</li>
<li><p>模块定义</p>
<p>分为define(factory)和define(name，deps，factory)</p>
<pre><code class="js">// define(factory)
define(function(require, exports, module) &#123; 
  // 模块代码 
&#125;); 

// define(name，deps，factory)
define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) &#123; 
  // 模块代码 
&#125;); </code></pre>
</li>
<li><p>和AMD异同</p>
<p>CMD 推崇依赖就近，AMD 推崇依赖前置</p>
<pre><code class="js">// CMD
define(function(require, exports, module) &#123;   
    var a = require(&#39;./a&#39;)   
    a.doSomething()    
    var b = require(&#39;./b&#39;)   
    b.doSomething()    
    ... 
&#125;)
// AMD 
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) &#123;  // 依赖必须一开始就写好
    a.doSomething()
    ...
    b.doSomething()
    ...
&#125;) </code></pre>
</li>
</ul>
<h2 id="三、CommonJS"><a href="#三、CommonJS" class="headerlink" title="三、CommonJS"></a>三、CommonJS</h2><p>​ 以服务器为第一原则发展，同步加载</p>
<ul>
<li><p>加载</p>
<pre><code class="js">const package = require(&#39;module-name&#39;)</code></pre>
</li>
<li><p>导出</p>
<p>导出一个值</p>
<pre><code class="js">module.exports = value</code></pre>
<p>导出多个值</p>
<pre><code class="js">exports.a = 1
exports.b = 2
exports.c = 3</code></pre>
</li>
</ul>
<h2 id="四、UMD"><a href="#四、UMD" class="headerlink" title="四、UMD"></a>四、UMD</h2><p>umd是CommonJS和AMD结合的产物，是一个跨平台的解决方案。</p>
<p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>
<h2 id="五、ES-module"><a href="#五、ES-module" class="headerlink" title="五、ES module"></a>五、ES module</h2><pre><code class="js">// 报错1
export 1;
// 报错2
const m = 1;
export m;

// 接口名与模块内部变量之间，建立了一一对应的关系
// 写法1
export const m = 1;
// 写法2
const m = 1；
export &#123; m &#125;;
// 写法3
const m = 1；
export &#123; m as module &#125;;
</code></pre>
<pre><code class="js">// 类似于对象解构
// module.js
export const m = 1;
// index.js
// 注意，这里的m得和被加载的模块输出的接口名对应
import &#123; m &#125; from &#39;./module&#39;;
// 若是想为输入的变量取名
import &#123; m as m1 &#125;  &#39;./module&#39;;
// 值得注意的是，import是编译阶段，所以不能动态加载，比如下面写法是错误的。因为&#39;a&#39; + &#39;b&#39;在运行阶段才能取到值，运行阶段在编译阶段之后
import &#123; &#39;a&#39; + &#39;b&#39; &#125; from &#39;./module&#39;;
// 若是只是想运行被加载的模块，如下
// 值得注意的是，即使加载两次也只是运行一次
import &#39;./module&#39;;
// 整体加载
import * as module from &#39;./module&#39;;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhaoda.net/webpack-handbook/amd.html">AMD 规范</a></li>
<li><a href="[http://www.ruanyifeng.com/blog/2012/11/require_js.html](http://www.ruanyifeng.com/blog/2012/11/require_js.html)">Javascript模块化编程（二）：require.js的用法</a></li>
<li><a href="https://blog.csdn.net/mm_hello11/article/details/78958334">amd和cmd规范的区别</a></li>
<li><a href="https://github.com/seajs/seajs/issues/242">cmd官方规范</a></li>
<li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">amd官方规范</a></li>
<li><a href="https://juejin.im/post/5b7d2f45e51d4538826f4c28">AMD , CMD, CommonJS，ES Module，UMD</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题目收集（持续更新）</title>
    <url>/2019/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%94%B6%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前端面试题目收集（持续更新）"><a href="#前端面试题目收集（持续更新）" class="headerlink" title="前端面试题目收集（持续更新）"></a>前端面试题目收集（持续更新）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>这里进行了一些常用面试题目的搜集，可供面试前参考，先罗列一遍，后期打算再进行分类整理</p>
<p>学习一个东西，需要带有目的、带有问题去学，不能为了学而学</p>
</blockquote>
<h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p>之前每次面试前，看一篇自己的总结面试题，感觉很好，但是每次这样效果太低下，一个个题目看，然后再进行回想，每个题目在你脑中渐渐形成一个孤立的荒岛，为了加快效率，希望大家<strong>构建自己的知识体系</strong></p>
<p>接下来，我自己罗列下前端知识体系，每次面试前根据知识体系回想回想一遍，把知识联系起来，形成一棵树，然后再用具体题目去充实上面的每个子树吧</p>
<ul>
<li>浏览器相关 （加载过程、三级缓存、<a href="https://juejin.cn/post/6844903764566999054#heading-11">浏览器缓存</a>、垃圾回收、<a href="https://juejin.cn/post/6844904016325902344#heading-13">v8垃圾回收</a>、<a href="https://juejin.cn/post/6844903638238756878#heading-4">事件循环</a> <a href="https://zhuanlan.zhihu.com/p/33058983">其他参考</a>、<a href="https://segmentfault.com/a/1190000018935873">Ajax</a>、<a href="http://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html">浏览器工作原理</a>、<a href="https://juejin.cn/post/6844903593275817998#heading-3">缓存</a>）</li>
<li>网络 （<a href="https://zhuanlan.zhihu.com/p/53374516">tcp三次握手四次挥手</a>、http、https 握手过程、<a href="https://blog.csdn.net/qq_22238021/article/details/80279001">网络五层协议</a>、XSS/CSRF/sql 注入等网络安全问题）</li>
<li>js （类型判断、原型链、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this 指向</a>、异步函数、继承、设计模式、设计原则、es6、<a href="https://github.com/mqyqingfeng/Blog/issues/155">浮点数</a>、深拷贝浅拷贝）</li>
<li>css （BFC、清除浮动、居中、css3 实现三角形、主题切换方案、<a href="https://zhuanlan.zhihu.com/p/41604775">css 样式权重</a>、<a href="https://segmentfault.com/a/1190000010780991">css3</a>、<a href="https://segmentfault.com/a/1190000012739764">浮动</a>）</li>
<li>html （语义化、canvas、空标签有哪些）</li>
<li>node.js （express、koa <a href="https://juejin.cn/post/6957258059022499854">洋葱模型</a>、eventEmitter的实现、事件循环、微任务与宏任务、async awiat、错误处理、pm2 的使用、docker的使用）</li>
<li>Vue （双向绑定的原理 （<a href="https://juejin.cn/post/6844903479044112391">1</a>、<a href="https://juejin.cn/post/6844903869730799629#heading-10">2</a>）、v-model 的原理、vue-router 的实现、vuex 的实现、vue3.0 的新特性）</li>
<li>React （<a href="https://www.zhihu.com/question/309891718">vue 和 react 的区别</a>、vuex 和 redux的区别、react 的函数式组件、immutable、redux实现、fiber 的原理、React16 的新特性、hook 的使用、生命周期）</li>
<li><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/">前端性能优化</a> （方案、性能监控）</li>
<li>webpack （配置、各种 loader、原理、性能优化：多线程打包、代码分割、按需加载）</li>
<li>基础算法 （排序、链表、数、队列、栈）</li>
<li>git （命令、cli、rebase 用法）</li>
<li>服务器 (服务端渲染、ssr)</li>
<li>客户端 ：RN/Weex、原生 bridge</li>
<li>移动端（微信公众号开发、小程序、移动端问题：<a href="https://juejin.cn/post/6959736170158751780">1px 问题</a>、<a href="https://www.cnblogs.com/shytong/p/5463673.html">点击穿透</a>、图片懒加载）</li>
</ul>
<p>资料：<a href="https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd">字节飞书面试题</a></p>
<h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol>
<li>什么是cookie</li>
</ol>
<p>cookie 是由服务器生成并保存在客户端的小型文本文件，它的优点是：</p>
<ul>
<li>高扩展性和可用性，比如,可以通过良好的编程控制存储在cookie的信息大小</li>
<li>数据持久性，cookie 可以长期保存在浏览器中</li>
<li>一定的安全性，可以设置失效时间，通过加密技术和安全传送技术，防止信息被恶意串改</li>
</ul>
<p>缺点：</p>
<ul>
<li>cookie的长度和同一域名下的数量都有限制，长度不超过4k，数量firefox限制40，chrome没有限制</li>
<li>潜在的安全风险，cookie有可能被攻击者串改，或者被拦截</li>
<li>不适合保存状态，如一些防止表单重复提交的计时器</li>
<li>冗余，服务器不需要的信息也可能随cookie发送</li>
</ul>
<ol start="2">
<li>与session的区别</li>
</ol>
<p>session：服务端执行session机制时候会生成session的id值，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie(Session不一定必须依赖Cookie，也可以在url上)</p>
<h3 id="页面性能指标"><a href="#页面性能指标" class="headerlink" title="页面性能指标"></a>页面性能指标</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsdka5bj31pc0n6ti1.jpg" alt="蚂蚁金服如何把前端性能监控做到极致?"></p>
<p>页面加载时长是被清晰的标在这个页面的底部的。它是指 DOM <code>load</code> 事件触发完成，它的优点有：</p>
<ul>
<li>原生 API；</li>
<li>接受度高；</li>
<li>感知明显（浏览器 Tab 停止 loading）。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>无法准确反映页面加载性能；</li>
<li>易受特殊情况影响。</li>
</ul>
<p>为了解决这个问题，W3C 的工作小组引入了首次渲染 / 首次内容渲染。首次渲染是指第⼀个非网页背景像素渲染，⾸次内容渲染是指第一个⽂本、图像、背景图片或非白色 canvas/SVG 渲染。</p>
<p>相关：</p>
<p><a href="https://www.cnblogs.com/xiaohuochai/p/9182710.html">使用chrome开发者工具中的performance面板解决性能瓶颈</a></p>
<h3 id="高性能建站指南"><a href="#高性能建站指南" class="headerlink" title="高性能建站指南"></a>高性能建站指南</h3><ol>
<li>减少http请求 方式：合并css、js文件，使用精灵图</li>
<li>使用cdn加快加载速度</li>
<li>开启浏览器缓存</li>
<li>css放头部，减少白屏，防止其阻碍页面呈现，页面会等css加载完再呈现内容</li>
<li>js放底部，防止其阻塞资源并行加载，不能并行加载的原因是保证js的顺序</li>
<li>开启服务器gzip压缩</li>
</ol>
<h3 id="ajax实现"><a href="#ajax实现" class="headerlink" title="ajax实现"></a><a href="https://segmentfault.com/a/1190000018935873">ajax实现</a></h3><h3 id="获取DOM元素大小"><a href="#获取DOM元素大小" class="headerlink" title="获取DOM元素大小"></a>获取DOM元素大小</h3><ol>
<li><p>偏移量，元素布局的大小</p>
<ol>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth">offsetWidth</a>：偏移宽度 = content + padding + border</p>
</li>
<li><p>offsetHeight：偏移高度 = content + padding + border</p>
</li>
<li><p>offsetTop： 相对于offsetParent的偏移顶部 = border上边界外 ~ parent的border上边界内</p>
</li>
<li><p>offsetLeft：相对于offsetParent的偏移左侧部分 = border左边界外 ~ parent的border左边界内<br><img src="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth/dimensions-offset.png" alt="图2"></p>
</li>
</ol>
</li>
<li><p>客户区，元素里面的大小</p>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth">clientWidth</a>： 客户区宽度 = content + padding</li>
<li>clientHeight：客户区高度 = content + padding</li>
</ol>
</li>
<li><p>滚动区大小</p>
<ol>
<li>scrollWidth： 滚动区域宽度 = content</li>
<li>scrollHeight： 滚动区域高度 = content</li>
<li>scrollTop： 滚动区域顶部被遮住的内容</li>
<li>scrollLeft：滚动左边被遮住的内容</li>
</ol>
</li>
<li><p>getBoundingClientRect 返回left、right、top、bottom、width、height（与offsetXXXX一致，不知道为啥叫clientRect）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/IMG_20220314-225321438.png" alt="图 1"><br><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/IMG_20220331-233945937.png" alt="图 3">  </p>
<h3 id="前端跨页面通信"><a href="#前端跨页面通信" class="headerlink" title="前端跨页面通信"></a>前端跨页面通信</h3><ol>
<li>广播<ol>
<li>BoastcastChannel 进行页面广播，实例调用onmessage监听，postMessage发送</li>
<li>Service Worker 建立消息中转站，通过addEventListener方式监听， postMessage发送</li>
<li>LocalStorage ，通过storage方法监听，改变数据方式发送</li>
</ol>
</li>
<li>共享数据轮询<ol>
<li>cookie和indexDB</li>
<li>Shared Worker</li>
</ol>
</li>
<li>口口相传：window.open 获取打开页面的引用，opener获的被打开页面的引用</li>
<li>跨域方案：利用页面可以获取iframe引用的方法，使iframe在同一域名下通信</li>
</ol>
<p><a href="https://juejin.cn/post/6844903811232825357#heading-8">参考</a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="简述-HTTPS-的工作原理，如何实现的加密传输（SSL-TLS-的握手过程）"><a href="#简述-HTTPS-的工作原理，如何实现的加密传输（SSL-TLS-的握手过程）" class="headerlink" title="简述 HTTPS 的工作原理，如何实现的加密传输（SSL/TLS 的握手过程）"></a>简述 HTTPS 的工作原理，如何实现的加密传输（SSL/TLS 的握手过程）</h3><p>答：</p>
<p>简单描述下，https的是对网页整体内容进行加密，从而防止第三方恶意利用网站的加密传输技术</p>
<p>一般用户请求https时：</p>
<ul>
<li>客户端，把支持的加密方法（非对称加密：RSC，ECC，对称加密：DES，RC）、协议版本，生成随机码(客户端随机码 )发送到服务器</li>
<li>服务端选择其中一种加密方式和证书以及用私钥加密的服务端随机码发送到客户端</li>
<li>客户端验证证书否有效后，用公钥解密服务端随机码，生成随机key，用公钥加密随机key，发送到服务端</li>
<li>服务端生用私钥解码字符串随机key ，然后使用所有密码生成 Session key (客户端随机码+服务端随机码+随机key ) 作为对称加密的密码加密网页，并返回网页</li>
<li>客户端获取加密网页，使用 Session key (客户端随机码+服务端随机码+随机key )对内容进行解码，得到正确数据并显示在浏览器上</li>
</ul>
<p>上述过程只是根据个人记忆理解的描述，跟具体的步骤可能有些出入</p>
<p>这里有几个问题想说明下：</p>
<ul>
<li>为什么不直接使用公钥加密网页？因为网页往往较大，用公钥加密一般比较费时，而对称加密效率高但安全性低，故此选择了非对称加密和对称加密结合的方式进行</li>
<li>为什么要加入随机key？随机key是最重要的钥匙，和客户端随机码、服务端随机码是明文传输不一样，它是唯一不会被中间人获取的key。</li>
</ul>
<p><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">参考</a></p>
<h3 id="线程和进程的差别"><a href="#线程和进程的差别" class="headerlink" title="线程和进程的差别"></a>线程和进程的差别</h3><h3 id="http-2-0对于http-1-x有哪些优点？"><a href="#http-2-0对于http-1-x有哪些优点？" class="headerlink" title="http 2.0对于http 1.x有哪些优点？"></a>http 2.0对于http 1.x有哪些优点？</h3><ol>
<li><p>多路复用，多个http请求复用一个连接</p>
<blockquote>
<p>HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。<br>多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。<br>HTTP2中</p>
<ul>
<li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>单个连接上可以并行交错的请求和响应，之间互不干扰</li>
</ul>
</blockquote>
</li>
<li><p>二进制分帧，在应用层和传输层直接加了一个二进制分帧，把http请求的数据分割成更小的二进制帧，从而实现多个数据流复用同一个连接的目的，减轻了服务器的连接压力</p>
</li>
<li><p>首部压缩，采用了HPACH的新算法进行首部压缩，减轻报文体积</p>
</li>
<li><p>服务器推送，类似websocket</p>
</li>
</ol>
<p><a href="https://www.zhihu.com/question/34074946">参考</a></p>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p><strong>常见Web漏洞及其防范</strong></p>
<ul>
<li><p>1.XSS(Cross Site Scripting)跨站脚本攻击</p>
<ul>
<li>攻击方式：利用html的漏洞，让网页执行不存在的js代码，比如在评论里写进代码，用户浏览到当条评论就会执行此段代码</li>
<li>防范：客户端与服务端同时做htmlEncode和jsEncode。服务端保障安全，客户端提升体验。服务端可使用XSS Filter实现，nodejs可使用XSS相关中间件。</li>
</ul>
</li>
<li><p>2.CSRF（Cross-site request forgery）跨站请求伪造</p>
<ul>
<li>方式：伪装成用户发请求，如劫持用户cookie获取请求，伪装成用户进行银行卡转账</li>
<li>防范：通过HTTP的<a href="http://www.ruanyifeng.com/blog/2019/06/http-referer.html">Referer</a>字段验证请求是否来自信任网站</li>
</ul>
</li>
<li><p>3.SQL注入</p>
<ul>
<li>方式：SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作。例如：网页查询界面，在input注入sql</li>
<li>防范：服务器对查询的SQL语句进行预编译、校验请求参数。例如：nodejs使用sqlstring对sql语句进行预编译</li>
</ul>
</li>
<li><p>4.弱口令<br>防范：使用规则限制用户使用弱口令</p>
</li>
<li><p>5.非加密传输<br>防范：使用HTTPS(HTTPS原理：非对称加密交换密钥+对称加密数据+CA认证)</p>
</li>
<li><p>6.CFS(Cross Frame Script跨框架脚本攻击)与Clickjacking(点击劫持)</p>
<ul>
<li><p>方式：利用浏览器允许框架(frame)跨站包含其它页面的漏洞，在主框架的代码中加入scirpt，监视、盗取用户输入。</p>
</li>
<li><p>防范：服务端header设置X-Frame-Options为SAMEORIGIN</p>
</li>
<li><p>tip：使用 X-Frame-Options 有三个可选的值：</p>
<p>DENY：浏览器拒绝当前页面加载任何Frame页面</p>
<p>SAMEORIGIN：frame页面的地址只能为同源域名下的页面</p>
<p>ALLOW-FROM：允许frame加载的页面地址</p>
</li>
<li><p><a href="https://developer.aliyun.com/article/322260">参考</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="http2和http1的区别"><a href="#http2和http1的区别" class="headerlink" title="http2和http1的区别"></a>http2和http1的区别</h3><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><p>任务执行顺序： 同步任务、异步任务(顺序：微任务（promise，nextTick）、宏任务(setTimeout，setInterval、setImmediate))</p>
<p>参考：<a href="https://juejin.im/post/5b498d245188251b193d4059#heading-6]">宏任务与微任务</a></p>
<h3 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h3><p>新建一个对象，并把this指向这个它，同时调用构造函数，并继承构造函数</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">参考</a></p>
<h3 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h3><pre><code class="js">function parent(name) &#123;
    this.name = name

    return &#123;
        name: &#39;刘&#39;
    &#125;
&#125;

parent.prototype.car = &#39;bigCar&#39;

child = new parent(&#39;张&#39;)

console.log(&#39;child&#39;, child)

// 模拟实现

function _new() &#123;

    const  constructor = [].shift.call(arguments)

    const arg = [].slice.call(arguments)

    const obj = new Object()

    const ret = constructor.apply(obj, arg)

    obj.__proto__ = constructor.prototype

    return  ret instanceof Object ? ret : obj
&#125;

child1 = _new(parent, &#39;林&#39;)

console.log(&#39;child1&#39;, child1)</code></pre>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ol>
<li><p>意外的全局变量，解决： 在JavaScript文件中添加<code>&#39;use strict&#39;</code>，开启严格模式</p>
</li>
<li><p>被遗忘的定时器和回调函数，解决：在定时器完成工作的时候，手动清除定时器</p>
</li>
<li><p>DOM引用：js保留了DOM节点的引用，导致即使节点被删除，GC也没有回收</p>
</li>
<li><p>遗忘的事件监听器：如在单页面应用，组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收，解决：需要在组件销毁的时候移除相关的事件</p>
</li>
<li><p>闭包</p>
<ol>
<li><p>注意: 闭包本身没有错,不会引起内存泄漏.而是使用错误导致</p>
</li>
<li><p>如闭包return回来的函数没有被使用的话，就会造成内存泄露（没有使用，又回收不了）</p>
</li>
<li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大</p>
</li>
<li><p>循环引用。Ps: 可以<a href="https://www.zhihu.com/question/31078912">参考</a></p>
</li>
</ol>
<pre><code class="javascript">function handle () &#123;
       var element = document.getElementById(“testId”);
      // 闭包
       element.onclick = function ()&#123;
           alert(element.id)
       &#125;
   &#125;
// 闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</code></pre>
</li>
</ol>
<p>参考 <a href="https://segmentfault.com/a/1190000020231307#item-5-5">内存泄露</a></p>
<h3 id="原型链的相关知识"><a href="#原型链的相关知识" class="headerlink" title="原型链的相关知识"></a>原型链的相关知识</h3><p><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/IMG_20220225-175614012.png" alt="图 1">  </p>
<ul>
<li><p>什么是原型（prototype）？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型（也可以叫: 实例原型，原因是它也可以是构造函数创建的实例的原型）。</p>
</li>
<li><p><code>__proto__</code> 和 prototype 是什么？</p>
<ul>
<li><p><code>__proto__</code> 指向原型。</p>
</li>
<li><p>js 中<strong>每一个对象</strong>都有 <code>__proto__</code> 属性，但是只有<strong>函数</strong>才有 <strong>prototype</strong> 属性 (函数也是对象)。例子：</p>
</li>
</ul>
<pre><code class="js">    // 函数对象
    function Person() &#123;&#125;
  // 普通对象
  var obj = &#123;&#125;;

  obj.__proto__ === Object.prototype;//true

    obj.prototype === undefined;//true

    Person.__proto__ === Function.prototype;//true

    Person.prototype !== undefined;//true</code></pre>
<ul>
<li><p>prototype 指向原型。</p>
</li>
<li><p>所有函数都有 prototype 属性，除了 Function.prototype 外，它是函数对象，但是没有prototype属性。<code>Function.prototype.prototype === undefined;//true</code></p>
</li>
</ul>
</li>
<li><p>构造、实例、继承是指什么？</p>
<ul>
<li>在 js 中如果 A 对象是由 B 函数构造的（也可以说是 B 是 A 的实例），那么<code>A.__proto__ === B.prototype</code>。</li>
<li>原型链是基于<code>__proto__</code>形成的，继承是通过prototype实现的。</li>
</ul>
</li>
<li><p>Object 和 Function 的关系？</p>
<ul>
<li><p><strong>内置的 Object</strong> 其实是一个函数对象，它是由Function构造的。<code>Object.__proto__ === Function.prototype;</code></p>
</li>
<li><p><strong>内置的Function</strong>也是一个函数对象，它是通过自己来构造自己的。<code>Function.__proto__=== Function.prototype;//true</code></p>
</li>
<li><p><strong>Object.prototype</strong> 指向一个普通对象，它的<code>__proto__</code>是 null，它是 js 原型链的最顶端 。所以 Object.prototype 没有原型 。</p>
<pre><code class="js"> Object.prototype.__proto__=== null;//true
 Object.prototype.prototype === undefied;//true 对象没有prototype,除非是函数对象</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>函数也是对象，因为函数在创建时会继承 <code>Function.prototype</code>，<code>Function.prototype.__proto__</code>指向 Object.prototype。</p>
<pre><code class="js">  typeof Function.prototype.__proto__) === &quot;object&quot;;//true
  Function.prototype.__proto__=== Object.prototype;//true
  function a() &#123;&#125;
  a.__proto__.__proto__ === Object.prototype; //true</code></pre>
</li>
</ul>
<ul>
<li><p><strong><code>instanceof</code></strong> ：</p>
<ul>
<li><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测当前构造函数的 <code>prototype</code> 属性是否出现在当前实例对象的原型链</li>
<li>一图理清关系<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbszdheq1j310o0lgabp.jpg" alt="img"></li>
</ul>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/2">可参考</a></p>
</li>
</ul>
<h3 id="什么是事件捕获机制，DOM0和DOM2"><a href="#什么是事件捕获机制，DOM0和DOM2" class="headerlink" title="什么是事件捕获机制，DOM0和DOM2"></a>什么是事件捕获机制，DOM0和DOM2</h3><p>1、DOM0级事件</p>
<p>就是直接通过 onclick 等方式实现相应的事件</p>
<p>这说明 DOM0 级添加事件时，后面的事件会覆盖前面的事件，而 DOM2级则不会，多个事件都会执行；</p>
<p>另外，DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p>
<p>2、DOM1级事件</p>
<p>因为DOM 1一般只有设计规范没有具体实现,所以一般跳过</p>
<p>3、</p>
<p>DOM2级事件</p>
<p><strong>主流浏览器 DOM2 级事件是通过以下两个方法用于处理指定和删除事件处理程序的操作</strong></p>
<p>只有<strong>DOM2事件流包括三个阶段</strong>：</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p>即是事件捕获机制</p>
<p><a href="https://www.cnblogs.com/Leophen/p/11405579.html">参考</a></p>
<h3 id="理解变量提升"><a href="#理解变量提升" class="headerlink" title="理解变量提升"></a>理解变量提升</h3><ol>
<li>变量函数都会提升</li>
<li>函数声明提升(包括function(){}里面也算函数声明， 如果变量对象已经存在相同名称的属性，则完全替换这个属性)</li>
<li>变量声明提升，不会提升赋值（ 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性）</li>
</ol>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/5">深入变量对象</a></p>
<p><a href="https://juejin.im/post/5d36b06af265da1ba84ad143#heading-3">参考</a></p>
<h3 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h3><ol>
<li><em>变量声明、函数声明都会被提升到作用域顶处；</em></li>
<li>当出现相同名称时，优先级为：<strong>函数形参 &gt; 函数声明 &gt; 变量声明</strong></li>
<li>let const class都会提升，但是不会初始化，没有初始化（赋值）前会形成<strong>Temporal Dead Zone</strong>（暂缓性死区）</li>
</ol>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/5">参考</a></p>
<h3 id="前端模块化：CommonJS-AMD-CMD-ES6"><a href="#前端模块化：CommonJS-AMD-CMD-ES6" class="headerlink" title="前端模块化：CommonJS,AMD,CMD,ES6"></a>前端模块化：CommonJS,AMD,CMD,ES6</h3><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">参考</a></p>
<h3 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h3><ol>
<li><p>原型链继承 缺点：引用类型值的原型属性会被所有实例共享</p>
<pre><code class="js">function Parent() &#123;
    this.name = &#39;父亲&#39;; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
&#125;
Parent.prototype.say = function() &#123; // -- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
&#125;
function Child(like) &#123;
    this.like = like;
&#125;
Child.prototype = new Parent() // 核心

let boy1 = new Child()
let boy2 = new Child()</code></pre>
<p>补充：实际上所有类型的属性都会被共享，只不过值类型的属性，在修改时会在对象上新建属性覆盖，而值类型通过一些不改变原始地址的方式修改值时，所有实例都会被修改，因为此时实例记录的都是同一个原始地址</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtsqldzsj30s80jw0v2.jpg" alt="image-20200330115542949" style="zoom:50%;" />
</li>
<li><p>借用构造函数继承 缺点：父类的方法不能复用,每次都要新建一次方法</p>
<pre><code class="js">function Parent(name) &#123;
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
     this.arr = [1]; // (该属性，强调私有)
    this.say = function() &#123; // 实例引用属性 (该属性，强调复用，需要共享)
        console.log(&#39;hello&#39;)
    &#125;
&#125;
function Child(name,like) &#123;
    Parent.call(this,name);  // 核心
    this.like = like;
&#125;
let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;);
let boy2 = new Child(&#39;小明&#39;, &#39;orange &#39;);</code></pre>
</li>
<li><p>组合继承 缺点：两次调用构造方法</p>
<pre><code class="js">function Parent(name) &#123;
    this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
    this.arr = [1]; // (该属性，强调私有)
&#125;
Parent.prototype.say = function() &#123; // --- 将需要复用、共享的方法定义在父类原型上 
    console.log(&#39;hello&#39;)
&#125;
function Child(name,like) &#123;
    Parent.call(this,name) // 核心   第二次
    this.like = like;
&#125;
Child.prototype = new Parent() // 核心   第一次

&lt;!--这里是修复构造函数指向的代码--&gt;

let boy1 = new Child(&#39;小红&#39;,&#39;apple&#39;)
let boy2 = new Child(&#39;小明&#39;,&#39;orange&#39;)</code></pre>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000015216289#item-2-5">参考</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/16">参考2</a></p>
<h3 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h3><ol>
<li><p>Object对象函数和对象字面量</p>
</li>
<li><p>工厂模式</p>
<p>用函数创造一个对象</p>
<p>缺点：没有解决对象识别的问题？</p>
<pre><code class="js">function person(name) &#123;
  let obj = new Object()
  obj.name = name
  obj.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>原型链模式</p>
<p>用类创造一个对象</p>
<p>缺点：共享了方法属性</p>
<pre><code class="js">function person() &#123;
&#125;
person.prototype.name = name
person.prototype.say = function()&#123;
  alert(&#39;say&#39;)
&#125;
let person1 = new preson()</code></pre>
</li>
<li><p>构造函数模式</p>
<p>用类创造一个对象</p>
<p>缺点：每次新建时方法都会被创建一次</p>
<pre><code class="js">function person(name) &#123;
  this.name = name
  this.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
<li><p>组合使用原型链模式和构造函数模式<br>用类创造一个对象</p>
<pre><code class="js">function person(name) &#123;
  this.name = name
  this.say = function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
person.prototype = &#123;
  constructor: person,
  say: function()&#123;
  alert(&#39;say&#39;)
 &#125;
&#125;
let person1 = new preson(&#39;钟汉良&#39;)</code></pre>
</li>
</ol>
<h3 id="关于-javascript-中的-this"><a href="#关于-javascript-中的-this" class="headerlink" title="关于 javascript 中的 this"></a>关于 javascript 中的 this</h3><p>javascript 中的 this 和 OO 语言（如：java、C#）的 this 有着比较大的差异。</p>
<ul>
<li>1 请说明下方代码片段中对于 this 的使用是否正确，不正确的话，问题在哪里，如何修改？</li>
<li>2 写些小的代码片段说明一下你理解的 this。</li>
</ul>
<pre><code class="javascript">class Handler &#123;
  get (req, res) &#123;
    const type = req.query.type
    this[type](req, res)
  &#125;

  typeA (req, res) &#123;
    res.send(&#39;hello a&#39;)
  &#125;

  typeB (req, res) &#123;
    res.send(&#39;hello b&#39;)
  &#125;
&#125;

const express = require(&#39;express&#39;)
const app = express()

const handler = new Handler()
app.use(&#39;/&#39;, handler.get)</code></pre>
<p>答：</p>
<ul>
<li>不正确，问题在执行<code>app.use(&#39;/&#39;, handler.get)</code> 时,改变了this的指向， 因为此时函数中的this是根据上下文指定的</li>
<li>修改方式:</li>
</ul>
<pre><code class="javascript">const handler = function (req, res) &#123;
  const hand = new Handler()
  hand.get(req, res)
&#125;

app.use(&#39;/&#39;, handler)
</code></pre>
<ul>
<li>代码片段：</li>
</ul>
<pre><code class="js">const fun = function() &#123; console.log(this) &#125;
fun() //指向全局

const obj = &#123; objFun : fun &#125;
obj.objFun() //指向obj

fun.call(obj) //指向obj

const person = function () &#123; this.name = &#39;lili&#39; &#125;
myName = new person()
console.log(myName.name) //&#39;lili&#39;

const func = () =&gt; &#123; console.log(this) &#125;
func() //指向全局
func.call(obj) //指向全局</code></pre>
<h3 id="介绍一下-import-和-require-有什么区别"><a href="#介绍一下-import-和-require-有什么区别" class="headerlink" title="介绍一下 import 和 require 有什么区别"></a>介绍一下 import 和 require 有什么区别</h3><p>答：</p>
<p>import：es6的模块加载规范，可用于浏览器环境和node环境(需要babal)</p>
<p>require：commonJS的加载规范，主要用于node环境</p>
<h3 id="如何修复输出值中的-undefined-？-阿里"><a href="#如何修复输出值中的-undefined-？-阿里" class="headerlink" title="如何修复输出值中的 undefined ？(阿里)"></a>如何修复输出值中的 undefined ？(阿里)</h3><pre><code class="javascript">function LateBloomer()&#123;
    this.petalCount = Math.ceil(Math.random()*2 + 1);
&#125;
LateBloomer.prototype.bloom = function()&#123;
    window.setTimeout(this.declare, 1000);
&#125;
LateBloomer.prototype.declare = function()&#123;
    console.log(&#39;I am a beautiful flower with &#39; + this.petalCount + &#39; petals&#39;);
&#125;
var flower = new LateBloomer();
flower.bloom();</code></pre>
<h3 id="普通函数和箭头函数this的区别"><a href="#普通函数和箭头函数this的区别" class="headerlink" title="普通函数和箭头函数this的区别"></a>普通函数和箭头函数this的区别</h3><p>区别：</p>
<p><strong>普通函数中的this:</strong></p>
<ol>
<li>this总是代表它的直接调用者, 例如 obj.func ,那么func中的this就是obj</li>
<li>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window</li>
<li>如果该函数是一个构造函数，this指针指向一个新的对象</li>
<li>在严格模式下,没有直接调用者的函数中的this是 undefined</li>
<li>使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象</li>
</ol>
<p><strong>箭头函数中的this</strong></p>
<ol start="2">
<li>箭头函数不会创建自己的<code>this</code>它只会从自己的<a href="https://chinese.freecodecamp.org/news/javascript-lexical-scope-tutorial/#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Lexical%20Scope%EF%BC%89,%E5%8F%88%E5%8F%AB%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%82">词法作用域链</a>的上一层继承<code>this</code>（可能环境是window）</li>
<li>call,apply,bind不改变this指向</li>
<li>不能作为构造函数</li>
<li>没有argument属性</li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">参考</a></p>
<h3 id="Proxy和defineProperty"><a href="#Proxy和defineProperty" class="headerlink" title="Proxy和defineProperty"></a>Proxy和defineProperty</h3><ul>
<li><p><strong>Object.defineProperty</strong> ：该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象</p>
<pre><code class="js">var obj = &#123;&#125;;
Object.defineProperty(obj, &quot;num&quot;, &#123;
    value : 1,
    writable : true,
    enumerable : true,
    configurable : true
&#125;);
//  对象 obj 拥有属性 num，值为 1
</code></pre>
</li>
<li><p><strong>proxy</strong> ：控制和修改Object的基本行为, 比起defindProperty可以重定义更多的行为，除了 get 和 set 之外，proxy 可以拦截多达 13 种操作</p>
<pre><code class="js">var proxy = new Proxy(target, handler);
/* new Proxy()表示生成一个Proxy实例
target参数表示所要拦截的目标对象
handler参数也是一个对象，用来定制拦截行为。*/
</code></pre>
</li>
</ul>
<p>参考：<a href="https://juejin.im/post/5be4f7cfe51d453339084530#heading-4">ES6 系列之 defineProperty 与 proxy</a></p>
<h3 id="Promise-all-和Promise-race模拟实现"><a href="#Promise-all-和Promise-race模拟实现" class="headerlink" title="Promise.all()和Promise.race模拟实现"></a>Promise.all()和Promise.race模拟实现</h3><ol>
<li><p>Promise.all()</p>
<pre><code class="js">
function promiseAll(arg = []) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        let timer = 0
        const rets = new Array(arg.length)

        for(let i = 0; i &lt; arg.length; i++) &#123;
          // Promise.resolve 为了兼容 arg中存在不是Promise的数   
            Promise.resolve(arg[i]).then((res) =&gt; &#123;
                rets[i] = res
                timer++
               // 重点，在最后一个完成事执行resolve，最终返回[]
                if(timer === arg.length) resovle(rets)
            &#125;).catch(e =&gt; reject(e))
        &#125;
    &#125;)
&#125;

promiseAll([Promise.resolve(1), Promise.resolve(2), 3]).then((res) =&gt; console.log(res))
// promiseAll([Promise.resolve(1), Promise.reject(2), 3, () =&gt; 4]).then((res) =&gt; console.log(res))</code></pre>
</li>
<li><p>Promise.race()</p>
<pre><code class="js">function promiseRace(arg = []) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    for(let i = 0; i &lt; arg.length; i++) &#123;
      Promise.resolve(arg[i]).then(res =&gt; &#123;
       // 有返回直接返回   
        resolve(res)
      &#125;).catch(e =&gt; reject(e))
    &#125;
  &#125;)
&#125;

promiseRace([new Promise(res =&gt; setTimeout(()=&gt; res(1), 100)), new Promise(res =&gt; setTimeout(()=&gt; res(2), 200))])
  .then((res) =&gt; console.log(res))</code></pre>
<p>关于Promise的更多实现可<a href="https://juejin.cn/post/6844904063570542599#heading-4">参考</a>（此文章，实现有些许冗余）</p>
</li>
</ol>
<p>Generators原理</p>
<p>通过利用闭包，保存生成器函数的上下文，并对生成器函数进行包装添加next方法，对next的调用会进入到对应状态机里，而实现next对生成器里面代码的暂停恢复控制。</p>
<p>简单的实例：</p>
<pre><code class="js">function* example() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;
var iter=example();
iter.next();//&#123;value:1，done:false&#125;
iter.next();//&#123;value:2，done:false&#125;
iter.next();//&#123;value:3，done:false&#125;
iter.next();//&#123;value:undefined，done:true&#125;</code></pre>
<p><a href="http://www.alloyteam.com/2016/02/generators-in-depth/">参考</a></p>
<h3 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul>
<li>defer：异步下载，不阻塞解析，HTML解析完成后执行，defer之间保证执行顺序</li>
<li><code>async</code>：异步下载，阻塞解析，下载完后尽快执行，async之间不保证顺序</li>
<li>创建<code>script</code>，在onload后，插入到<code>DOM</code>中，加载完毕后<code>callBcak</code></li>
</ul>
<p><a href="https://alienzhou.com/projects/fe-performance-journey/4-parse/#_2-%E4%BD%BF%E7%94%A8-defer-%E5%92%8C-async">参考</a></p>
<h3 id="判断js数据类型的方法"><a href="#判断js数据类型的方法" class="headerlink" title="判断js数据类型的方法"></a>判断js数据类型的方法</h3><ol>
<li><p>typeof</p>
<ul>
<li>对于除 null（返回 object 类型） 以外的基本类型，，均可以返回正确的结果。</li>
<li>除 function（返回  function 类型） 以外的引用类型，一律返回 object 类型。</li>
</ul>
</li>
<li><p>instanceof</p>
<ul>
<li><strong>instanceof 检测的是原型</strong></li>
<li><strong>instanceof 只能用来判断两个对象是否属于实例关系</strong> <strong>， 而不能判断一个对象实例具体属于哪种类型。</strong></li>
</ul>
</li>
<li><p>toString</p>
<p><code>Object.prototype.toString.call()</code></p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/onepixel/p/5126046.html">参考</a></p>
<h3 id="js-import的动态导入"><a href="#js-import的动态导入" class="headerlink" title="js import的动态导入"></a>js import的动态导入</h3><p><code>import(module)</code> 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。</p>
<p><a href="https://zh.javascript.info/modules-dynamic-imports#import-biao-da-shi">参考</a></p>
<p>扩展：</p>
<ol>
<li><p>其他动态导入方式：</p>
<ul>
<li>动态插入Script，并<a href="https://blog.csdn.net/qq_31411389/article/details/80502015">监听加载</a>script的onload（IE使用onreadystatechange）事件</li>
</ul>
</li>
<li><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">vue动态导入</a>使用也是这种方法</p>
</li>
</ol>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="CSS可以继承的属性"><a href="#CSS可以继承的属性" class="headerlink" title="CSS可以继承的属性"></a>CSS可以继承的属性</h3><ul>
<li><p>常用的css可继承的属性：</p>
<p>font：组合字体</p>
<p>font-family：规定元素的字体系列</p>
<p>font-weight：设置字体的粗细</p>
<p>font-size：设置字体的尺寸</p>
<p>font-style：定义字体的风格</p>
<p>text-indent：文本缩进</p>
<p>text-align：文本水平对齐</p>
<p>line-height：行高</p>
<p>color：文本颜色</p>
<p>visibility：元素可见性</p>
<p>光标属性：cursor</p>
</li>
<li><p>所有元素可以继承的属性：cursor</p>
</li>
<li><p>内联元素可以继承的属性：text-indent、text-align之外的文本系列属性</p>
</li>
<li><p>块级元素可以继承的属性：text-indent、text-align</p>
</li>
</ul>
<h3 id="CSS居中"><a href="#CSS居中" class="headerlink" title="CSS居中"></a>CSS居中</h3><ul>
<li>内联元素：<ul>
<li>水平：text-align</li>
<li>垂直：<ul>
<li>line-height：元素高度 (只对inline中文字有效)</li>
<li>vertical-alight：middle；</li>
</ul>
</li>
</ul>
</li>
<li>块级元素：<ul>
<li>flex：justify-content:center;  align-item: center;</li>
<li>position<ul>
<li>定宽：position: absolute; left: 50%; top: 50%; margin-left:负自身宽度的一半; margin-top:负自身高度的一半;</li>
<li>不定宽：<ul>
<li>position: absolute; left: 50%; top:50%; transfrom: translate(-50%,-50%);</li>
<li>position: absolute; left: 0; rihgt: 0; top: 0 ; bottom: 0; margin: auto;</li>
</ul>
</li>
</ul>
</li>
<li>table：diplay：table-cell;vertical-align: middle;</li>
<li>margin：0 auto; （只能水平居中）</li>
</ul>
</li>
</ul>
<h3 id="clientWidth和offsetWidth宽度"><a href="#clientWidth和offsetWidth宽度" class="headerlink" title="clientWidth和offsetWidth宽度"></a>clientWidth和offsetWidth宽度</h3><p>ele.clientWidth = 宽度 + padding</p>
<p>ele.offsetWidth = 宽度 + padding + border</p>
<p>ele.scrollTop = 被卷去的上侧距离</p>
<p>ele.scrollHeight = 自身实际的高度，可见部分加上不可见部分（不包括边框）</p>
<p>ele.offsetTop = 当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的顶部内边距的距离</p>
<p>Ps：懒加载是利用图片的ele.offsetTop和父元素的scrollTop的差判断图片是否在屏幕范围内</p>
<h3 id="什么是reflow和repaint"><a href="#什么是reflow和repaint" class="headerlink" title="什么是reflow和repaint"></a>什么是reflow和repaint</h3><blockquote>
<p>repaint（重绘）：如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint。repaint 的速度明显快于 reflow</p>
<p>reflow（回流）：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。</p>
</blockquote>
<p>reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>下面情况会导致reflow发生</p>
<p>1：改变窗口大小</p>
<p>2：改变文字大小</p>
<p>3：内容的改变，如用户在输入框中敲字</p>
<p>4：激活伪类，如:hover</p>
<p>5：操作class属性</p>
<p>6：脚本操作DOM</p>
<p>7：计算offsetWidth和offsetHeight</p>
<p>8：设置style属性</p>
<p>相关扩展：<a href="https://www.zhihu.com/question/33629083">在移动端使用transform: translate代替top left marg等做位移有好处么 ？</a></p>
<h3 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<p>哪些情况会产生BFC:</p>
<ol>
<li>根元素</li>
<li>浮动元素：float 不为 none</li>
<li>定位元素：position 不为 static</li>
<li>overflow 不为 visible</li>
<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>
</ol>
<p>BFC 特性及应用：</p>
<ul>
<li>同一个 BFC 下外边距会发生重叠，不同 BFC 不会重叠</li>
<li>内部第一层计算高度时浮动的元素参与计算（清除浮动）</li>
<li>内部第一层浮动元素不重叠（其实同上）</li>
<li>应用：用来实现<a href="https://juejin.cn/post/6844903817104850952#heading-4">两列自适应布局</a>、清除浮动</li>
</ul>
<h3 id="CSS-百分比参照问题"><a href="#CSS-百分比参照问题" class="headerlink" title="CSS 百分比参照问题"></a>CSS 百分比参照问题</h3><ul>
<li>参照父元素<strong>宽度</strong>的元素：padding <strong>margin</strong> width text-indent</li>
<li>参照父元素高度的元素：height</li>
<li>参照父元素属性:font-size line-height</li>
<li>参照transform-box（可能为当前元素）属性：transform: translate(30%, 50%);</li>
<li>特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度</li>
</ul>
<h3 id="渲染树的形成原理"><a href="#渲染树的形成原理" class="headerlink" title="渲染树的形成原理"></a><a href="https://juejin.im/post/5da2f4f7f265da5b8a516502#heading-7">渲染树的形成原理</a></h3><blockquote>
<p>注意点:</p>
<ol>
<li>CSS解析可以与DOM解析同进行</li>
<li>如果只有 CSS 和 HTML 的页面，CSS 不会影响 DOM 树的创建，但是如果页面中还有 JavaScript，结论就不一样了。</li>
</ol>
</blockquote>
<h3 id="css样式优先级"><a href="#css样式优先级" class="headerlink" title="css样式优先级"></a>css样式优先级</h3><p>!important &gt; 内联 &gt; id &gt; class（=伪类、属性选择器） &gt; 标签选择器（=伪元素）</p>
<p><img src="https://pic3.zhimg.com/80/v2-b1a9fedf320754acb1d7766c6548d5f6_1440w.webp" alt="img"></p>
<p><a href="https://zhuanlan.zhihu.com/p/41604775">参考</a></p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。</td>
</tr>
<tr>
<td>HEAD</td>
<td>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</td>
</tr>
<tr>
<td>POST</td>
<td>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。</td>
</tr>
<tr>
<td>TRACE</td>
<td>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</td>
</tr>
</tbody></table>
<p><a href="https://juejin.im/entry/5b004085f265da0b886daf7c">参考</a></p>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h3 id="node中间件的原理"><a href="#node中间件的原理" class="headerlink" title="node中间件的原理"></a>node中间件的原理</h3><p>一个请求发送到服务器后，它的生命周期是 先收到request（请求），然后服务端处理，处理完了以后发送response（响应）回去</p>
<p>app.use 加载用于处理http请求的middleware（中间件），当一个请求来的时候，会依次被这些 middlewares处理。</p>
<p>中间件其是一个函数，在响应发送之前对请求进行一些操作</p>
<p>这个函数有些不太一样，它还有一个next参数，而这个next也是一个函数，它表示函数数组中的下一个函数</p>
<p>express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组</p>
<p>ps：<a href="https://cloud.tencent.com/developer/article/1467268">koa与express的中间件机制揭秘</a> by 挥刀北上</p>
<h3 id="node事件驱动模型"><a href="#node事件驱动模型" class="headerlink" title="node事件驱动模型"></a>node事件驱动模型</h3><p><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/IMG_20220409-211402538.png" alt="图 7">  </p>
<p>关于线程： 除了你的代码是单线程，其余都是多线程（线程池），nodejs本身是事件驱动，一个io事件完成会被放到一个事件队列中，主线程负责轮询这个队列，然后执行相应的回调函数。</p>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">参考1</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html">参考2</a></p>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">Node.js 事件循环，定时器和 process.nextTick()</a> by node.js</p>
<ol>
<li><strong>process.nextTick</strong></li>
</ol>
<p><code>process.nextTick</code>这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018022302.png" alt="img"></p>
<p>Node 执行完所有同步任务，接下来就会执行<code>process.nextTick</code>的任务队列。</p>
<ol start="2">
<li><strong>微任务和宏任务在Node的执行顺序</strong></li>
</ol>
<p>Node 10以前：</p>
<ul>
<li>执行完一个阶段的所有任务</li>
<li>执行完nextTick队列里面的内容</li>
<li>然后执行完微任务队列的内容</li>
</ul>
<p>Node 11以后：<br>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。</p>
<ol start="3">
<li><strong><code>setImmediate()</code> 对比 <code>setTimeout()</code></strong></li>
</ol>
<p><code>setImmediate()</code> 和 <code>setTimeout()</code> 很类似，但是基于被调用的时机，他们也有不同表现。</p>
<ul>
<li><code>setImmediate()</code> 设计为一旦在当前 <strong>轮询</strong> 阶段完成， 就执行脚本。</li>
<li><code>setTimeout()</code> 在最小阈值（ms 单位）过后运行脚本。</li>
</ul>
<p>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时器将受进程性能的约束（这可能会受到计算机上其他正在运行应用程序的影响）。</p>
<p>例如，如果运行以下不在 I/O 周期（即主模块）内的脚本(可以理解为<strong>初始化时</strong>)，则执行两个计时器的顺序是非确定性的，因为它受进程性能的约束：</p>
<blockquote>
<p>当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入 <a href="https://nodejs.org/api/repl.html#repl_repl">REPL</a>，本文不涉及到），它可能会调用一些异步的 API、调度定时器，或者调用 <code>process.nextTick()</code>，然后开始处理事件循环。</p>
</blockquote>
<pre><code class="js">// timeout_vs_immediate.js
setTimeout(() =&gt; &#123;
  console.log(&#39;timeout&#39;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&#39;immediate&#39;);
&#125;);
$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout</code></pre>
<p>但是，如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用：</p>
<pre><code class="js">// timeout_vs_immediate.js
const fs = require(&#39;fs&#39;);

fs.readFile(__filename, () =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timeout&#39;);
  &#125;, 0);
  setImmediate(() =&gt; &#123;
    console.log(&#39;immediate&#39;);
  &#125;);
&#125;);
$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout</code></pre>
<h3 id="amqp"><a href="#amqp" class="headerlink" title="amqp"></a><a href="https://juejin.im/post/5dfc93a5f265da339b500273">amqp</a></h3><h3 id="Node-的-Event-Loop-6个阶段"><a href="#Node-的-Event-Loop-6个阶段" class="headerlink" title="Node 的 Event Loop: 6个阶段"></a>Node 的 Event Loop: 6个阶段</h3><ul>
<li><p>timer 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p>
</li>
<li><p>I/O 阶段: 执行上轮循环残流的<code>callback</code></p>
</li>
<li><p>idle, prepare</p>
</li>
<li><p>poll: 等待回调</p>
<ul>
<li><ol>
<li>执行回调</li>
</ol>
</li>
<li><ol>
<li>执行定时器</li>
</ol>
<ul>
<li>如有到期的<code>setTimeout / setInterval</code>， 则返回 timer 阶段</li>
<li>如有<code>setImmediate</code>，则前往 check 阶段</li>
</ul>
</li>
</ul>
</li>
<li><p>check</p>
<ul>
<li>执行<code>setImmediate</code></li>
</ul>
</li>
<li><p>close callbacks</p>
</li>
</ul>
<h3 id="浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="浏览器与Node的事件循环(Event Loop)有何区别"></a><a href="https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/">浏览器与Node的事件循环(Event Loop)有何区别</a></h3><p>node跟浏览器端相差比较大，timers 阶段有几个 setTimeout/setInterval 都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务</p>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="虚拟dom的原理"><a href="#虚拟dom的原理" class="headerlink" title="虚拟dom的原理"></a>虚拟dom的原理</h3><h3 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h3><p>利用观察者模式，实现响应式。实现了 Observer 和 Watcher 对应观察者模式中的观察者和订阅者。</p>
<p>其中 Observer 利用 Object.defindePropotype 劫持了数据的 getter 和 setter 方法监听数据的变化，在 getter 中添加 Watcher 到依赖列表dep，在 setter 中在数据变化的时候，根据 dep 通知对应的 Watcher。</p>
<p>Watcher是订阅者，在vue 编译模板的时候添加到对应的依赖，里面包含 update 方法，用于在数据变化的时候调用更新。</p>
<p><a href="https://juejin.cn/post/6844903869730799629">参考</a></p>
<h3 id="virtualDOM是什么"><a href="#virtualDOM是什么" class="headerlink" title="virtualDOM是什么"></a>virtualDOM是什么</h3><p>virtualDOM是DOM节点树的一个映射</p>
<p>使用原因：真实dom依赖环境，操作开销大，节点渲染频繁</p>
<p>它的作用是，每次数据变化时，通过virtualDOM执行diff算法进行对比得到差异结果后，再一次性对DOM进行批量更新操作</p>
<p>diff算法不是传统意义上的通过深度优先遍历DFS算法算法，它做了以下几点改进：</p>
<ol>
<li><p>同层级的节点进行比较</p>
<p>在新旧节点树之间按层级进行diff得到差异，可以算法复杂度降低到O(n)</p>
</li>
<li><p>按类型进行diff</p>
<p>VirtualDOM只对相同类型的同一个节点进行diff，当新旧节点发生了类型的改变时，则并不进行子树的比较，直接创建新类型的VirtualDOM，替换旧节点</p>
<p>例如同类型的组件照常进行比较，不同类型的组件不进行比较直接替换节点</p>
</li>
<li><p>列表按key进行diff</p>
<p>在没有key值的列表diff中，只能通过按顺序进行每个元素的对比，更新，插入与删除</p>
<p>如果有key就能够快速识别新旧列表之间的变化内容</p>
</li>
</ol>
<p><a href="https://juejin.im/post/5d81eec56fb9a06add4e63ba">参考</a></p>
<h3 id="vue组件通信的方式"><a href="#vue组件通信的方式" class="headerlink" title="vue组件通信的方式"></a>vue组件通信的方式</h3><ol>
<li><p>父组件向子组件</p>
<blockquote>
<p>props：从上往下传</p>
<p>$children：获取父组件额属性</p>
<p>Porvide/inject： 在父组件中通过 <code>provider</code> 来提供属性，然后在子组件中通过 inject 来注入变量，深层级应对</p>
</blockquote>
</li>
<li><p>子组件向父组件</p>
<blockquote>
<p><code>$emit</code>： 传入事件和参数，父组件用<code>$on</code>监听</p>
<p>$parent</p>
</blockquote>
</li>
<li><p>其他</p>
<blockquote>
<p>中央事件总线EventBus：通过新建一个 <code>Vue</code> 事件 <code>bus</code> 对象，然后通过 <code>bus.$emit</code> 触发事件，<code>bus.$on</code> 监听触发的事件</p>
<p>vuex</p>
</blockquote>
</li>
</ol>
<h3 id="Vue-中的-computed-是如何实现的"><a href="#Vue-中的-computed-是如何实现的" class="headerlink" title="Vue 中的 computed 是如何实现的"></a>Vue 中的 computed 是如何实现的</h3><p>computed内部实现了一个惰性的watcher，在实例化的时候不会去求值，其内部通过dirty属性标记计算属性是否需要重新求值。当computed依赖的任一状态（不一定是return中的）发生变化，都会通知这个惰性watcher，让它把dirty属性设置为true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p>
<p>computed本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的getter，而不是用户定义的方法。</p>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html#computed">参考</a></p>
<h3 id="vue-nextTick实现"><a href="#vue-nextTick实现" class="headerlink" title="vue nextTick实现"></a>vue nextTick实现</h3><p>等待下一次 DOM 更新刷新的工具方法。</p>
<p>利用事件循环中的微任务（或宏任务）实现：Promise || MutationObserve || setImmediate || setTimeout</p>
<p>注意：dom的更新是同步的，前一步更新后一步就能拿到结果，所以nextTick能获取dom操作后的结果</p>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">参考</a></p>
<h3 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h3><ol>
<li>数据响应式： <a href="https://www.zhihu.com/question/309891718">push-base VS pull-base</a></li>
<li>数据流方向：双向数据流 VS 单向数据流</li>
<li>代码组织方式：模板代码 VS 函数式编程</li>
</ol>
<p>引申：vuex 和 react-redux 区别：数据可变性（vuex直接修改数据，reat-redux用的是不可变数据，每次返回一个新的state）</p>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><a href="https://juejin.cn/post/6844903961745440775">vue-router</a></h3><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="React-组件的生命周期方法"><a href="#React-组件的生命周期方法" class="headerlink" title="React 组件的生命周期方法"></a>React 组件的生命周期方法</h3><p>一些最重要的生命周期方法是：</p>
<ol>
<li><strong><em>componentWillMount**</em></strong>()** – 在渲染之前执行，在客户端和服务器端都会执行。</li>
<li><strong><em>componentDidMount**</em></strong>()** – 仅在第一次渲染后在客户端执行。</li>
<li><strong><em>componentWillReceiveProps**</em></strong>()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</li>
<li><strong><em>shouldComponentUpdate**</em></strong>()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回<strong>true</strong> 否则返回 <strong>false</strong>。默认情况下，它返回 false。</li>
<li><strong><em>componentWillUpdate**</em></strong>()** – 在 DOM 中进行渲染之前调用。</li>
<li><strong><em>componentDidUpdate**</em></strong>()** – 在渲染发生后立即调用。</li>
<li><strong><em>componentWillUnmount**</em></strong>()** – 从 DOM 卸载组件后调用。用于清理内存空间。</li>
</ol>
<h3 id="react-hook的优缺点"><a href="#react-hook的优缺点" class="headerlink" title="react hook的优缺点"></a>react hook的优缺点</h3><ul>
<li>优点<ul>
<li>易于复用，可以组合各种hook，方便移植</li>
<li>代码量更少</li>
</ul>
</li>
<li>缺点<ul>
<li>响应式的useEffect，形成一条依赖链，没有componentDidmount生命周期好用。</li>
<li>不擅长异步。容易引入组件的旧值，类似闭包。解决：useRef保存引用。</li>
<li>不能放在if 语句里面使用。因为组件hookStates存放hooks数据，state判断调用哪个hook，是通过hook的调用顺序，if会使得调用顺序不可控。</li>
</ul>
</li>
<li>避免缺点：<ul>
<li>useEffect尽量少依赖</li>
<li>组件划分小而完整</li>
<li>异步尝试传入从组件传入函数参数</li>
</ul>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/88593858">参考</a></p>
<h3 id="redux-简述"><a href="#redux-简述" class="headerlink" title="redux 简述"></a>redux 简述</h3><p>一个状态管理容器，生成一个只能使用 action 通过 reduer 变更的 state （传入state和action返回一个新的state）</p>
<p><a href="https://cn.redux.js.org/introduction/getting-started">参考</a></p>
<h3 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h3><ul>
<li>useEffect 怎么替代 componentDidMount，可以第二个参数传入[],如：<code>useEffect(()=&gt; &#123;&#125;, [])</code></li>
</ul>
<p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">参考</a></p>
<h3 id="react-合成事件"><a href="#react-合成事件" class="headerlink" title="react 合成事件"></a>react 合成事件</h3><p><a href="https://juejin.cn/post/6844903988794671117#heading-1">参考</a></p>
<h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p><a href="https://reactjs.org/docs/faq-internals.html#what-is-react-fiber">fiber</a> 是一个 <strong>reconciliation engine</strong>，实现了 virtual DOM 的增量渲染，也就是在 reconciliation 阶段实现了 virtual DOM 结构的同时，也可以拆成多个子任务执行 diff 任务，最后统一在 commit 阶段执行 side-effect 和 相关浏览器 DOM 的渲染</p>
<p>概念：<a href="https://juejin.cn/post/7082556430217117726#heading-1">requestAnimationFrame</a></p>
<p><a href="https://segmentfault.com/a/1190000018250127">形象生动，但概念不清楚或者缺失</a></p>
<p><a href="https://juejin.cn/post/6844903655401848846">源码解析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/57346388">深度解析</a></p>
<p><a href="https://juejin.cn/post/6991656792639930382#heading-14">react17 diff 算法</a></p>
<h3 id="setState是同步还是异步的"><a href="#setState是同步还是异步的" class="headerlink" title="setState是同步还是异步的"></a>setState是同步还是异步的</h3><p>setState函数是本身是同步的，但注意：</p>
<ul>
<li>在合事件中是类似异步的，因为事件在更新机制中触发了isBranchUpdate为true，次数多次setState会存入队列，在更新末统一执行，所以此时不能立即拿到结果</li>
<li>异步函数和原生事件中，根据js异步机制，如果在更新机制中，会等同步的更新机制更新完，再执行异步任务，此时更新完的isBranchUpdate为false，同理不在更新机制 isBranchUpdate 也为 false，所以此时setState后可以立即拿到结果</li>
</ul>
<p><a href="https://juejin.cn/post/6844903781813993486">参考</a></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="如果要实现一个组件的动态加载，会用webpack的什么方法"><a href="#如果要实现一个组件的动态加载，会用webpack的什么方法" class="headerlink" title="如果要实现一个组件的动态加载，会用webpack的什么方法"></a>如果要实现一个组件的动态加载，会用webpack的什么方法</h3><p>import()</p>
<h3 id="webpack-中-loader-和-plugin-的区别是什么"><a href="#webpack-中-loader-和-plugin-的区别是什么" class="headerlink" title="webpack 中 loader 和 plugin 的区别是什么"></a>webpack 中 loader 和 plugin 的区别是什么</h3><ul>
<li><p>loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。</p>
</li>
<li><p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p>
</li>
</ul>
<p>[参考](While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.)</p>
<h3 id="性能优化-webpack-汇总"><a href="#性能优化-webpack-汇总" class="headerlink" title="性能优化 webpack 汇总"></a><a href="https://juejin.im/post/5dcc45136fb9a02b450c2818">性能优化 webpack 汇总</a></h3><ol>
<li><p>减少打包时间</p>
<ol>
<li>优化loader配置</li>
<li>happyPack插件开启多线程打包</li>
</ol>
</li>
<li><p>减少打包后的体积</p>
<ol>
<li>使用CDN放置部分资源</li>
<li>UglifyJS代码压缩</li>
</ol>
</li>
<li><p>开启 tree shaking 去除无用代码</p>
</li>
<li><p>优化打包后的加载速度</p>
<ol>
<li>分割代码以按需加载</li>
</ol>
</li>
</ol>
<p><a href="https://juejin.im/post/5b652b036fb9a04fa01d616b#heading-16">参考</a></p>
<h3 id="webpack异步加载原理"><a href="#webpack异步加载原理" class="headerlink" title="webpack异步加载原理"></a>webpack异步加载原理</h3><p><a href="https://blog.csdn.net/ywl570717586/article/details/79034322?ops_request_misc=&request_id=&biz_id=102&utm_term=webpack%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-79034322.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">参考</a></p>
<h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h3 id="组件设计原则"><a href="#组件设计原则" class="headerlink" title="组件设计原则"></a>组件设计原则</h3><ol>
<li>低耦合高内聚</li>
<li>分清业务组件和通用组件</li>
<li>健壮性，保证能在各种场合适用</li>
</ol>
<h3 id="前端常用的设计模式"><a href="#前端常用的设计模式" class="headerlink" title="前端常用的设计模式"></a>前端常用的设计模式</h3><ol>
<li><p>工厂模式</p>
<blockquote>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</p>
</blockquote>
<p>例子：父类就像工厂生产自行车，可能会有轮子、把手、踩踏板、刹车，但是不同型号的自行车会有不同的东西如变速器，这些交给子类生产线复制</p>
</li>
<li><p>单例模式</p>
<blockquote>
<p>一个单一的类，该类负责创建自己的对象，同时确保只有<strong>单个对象</strong>被创建，并提供一个访问它的全局访问点</p>
</blockquote>
<p>例子： 前端弹窗的实现，调用多次弹窗函数，只实例化一次弹窗</p>
</li>
<li><p>代理模式</p>
<blockquote>
<p>为其他对象提供一种代理层以控制对这个对象的访问，不直接访问对象</p>
</blockquote>
<p>例子：限制接口频繁访问访问数据库，可以做一层代理，一段时间</p>
</li>
<li><p>观察者模式</p>
<blockquote>
<p>存在一对多关系时，则使用观察者模式</p>
</blockquote>
<p>例子：vue的双向绑定，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p>vs：</p>
<p>发布/订阅模式</p>
<blockquote>
<p>之前是观察者模式的别名，现在有所区别，发布订阅模式相比观察者模式多了个事件通道作为调度中心</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmpgz17qoj30fe0acgp9.jpg" alt="img"></p>
</blockquote>
</li>
<li><p>状态模式</p>
<blockquote>
<p>关键是区分事物内部的状态，事物内部状态往往会带来事物的行为改变，即允许对象在内部状态发生改变时改变它的行为</p>
</blockquote>
</li>
<li><p>职责链模式</p>
<blockquote>
<p> 处理请求组成的一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象</p>
</blockquote>
</li>
<li><p>策略模式</p>
<blockquote>
<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</blockquote>
<p>例子：表单验证的实现，表单的各种校验函数封装成策略对象，通过外部参数组合使用表单校验</p>
<p>在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类 中，Context 将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样 便能表现出对象的多态性。</p>
<p>实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函 数发出“调用”的消息时，不同的函数会返回不同的执行结果。</p>
</li>
<li><p>适配器模式</p>
<blockquote>
<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>
</blockquote>
</li>
</ol>
<p><a href="https://www.cnblogs.com/tugenhua0707/p/5198407.html">Javascript设计模式详解</a></p>
<h3 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h3><ol>
<li><p>单一职责原则</p>
<blockquote>
<p>单一职责原则，一个类只提供一种功能，不要存在过多导致类变化的原因。</p>
</blockquote>
</li>
<li><p>开放封闭原则</p>
<blockquote>
<p>类，方法等应当对其扩展开放，对其修改封闭</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/adam-tan/markdown-image/master/img/IMG_20220405-152200355.png" alt="图 2">  </p>
</li>
<li><p>里氏替换原则</p>
<blockquote>
<p>子类必须能够替换它们的基类。</p>
</blockquote>
</li>
<li><p>依赖倒置原则</p>
<blockquote>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p>
</blockquote>
</li>
<li><p>接口分离原则</p>
<blockquote>
<p>使用多个专门的接口来取代一个统一的接口</p>
</blockquote>
</li>
<li><p>最少知识原则</p>
<blockquote>
<p>就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话</p>
</blockquote>
</li>
</ol>
<h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h2><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><p>应用层 报文 面向用户  http、FTP、DNS</p>
<p>传输层 报文段 端对端 TCP/UD、 socket</p>
<p>网络层 数据报 建立主机之间连接 ip、ARP、routing</p>
<p>数据链路层 帧 点对点 p2p、交换机</p>
<p>物理层 比特</p>
<p><a href="https://blog.csdn.net/qq_22238021/article/details/80279001">参考</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="H5移动端兼容问题"><a href="#H5移动端兼容问题" class="headerlink" title="H5移动端兼容问题"></a><a href="https://segmentfault.com/a/1190000015131445">H5移动端兼容问题</a></h3><h3 id="遇到大量if的代码如何优化"><a href="#遇到大量if的代码如何优化" class="headerlink" title="遇到大量if的代码如何优化"></a>遇到大量if的代码如何优化</h3><p>记住下面的口诀：</p>
<p>互斥条件表驱动</p>
<p>嵌套条件校验链</p>
<p>短路条件早return</p>
<p>零散条件可组合</p>
<blockquote>
<ol>
<li>互斥条件，表示几个条件之间是冲突的，不可能同时达成的。比如说一个数字，它不可能同时是4和2。在这种情况下用表驱动就非常合适，表驱动的核心是key-handler，拿某个key去对应某个handler，只要条件符合key，那么就执行对应的handler。</li>
<li>嵌套条件，表示几个条件是必须同时达成的，比如，只有在手机号码格式正确的情况下才执行某个操作，格式正确就包括必须是字符串、长度为11位、所有位都是数字这些条件，那么就可以使用校验链，比如通过描述的校验链：”string&amp;size:11&amp;numchar:0,*”。能用的形式很多，你可以直接使用&amp;&amp;逻辑运算符拼接条件，也可以把规则写成Validator。</li>
<li>短路条件，表示只要某个条件满足了，那么就不用再继续下面的任何操作了。比如传进来的参数是null、参数如果为0，就不会有其他操作等情况，都可以聚合这些条件，在一开始的时候就判断并且直接返回，或者程序在中间会产生一些可以直接判断为不需要继续往下操作的条件，那么同样是直接在当场就return。</li>
<li>零散条件，是指存在以上三种任意组合的条件形式，那么就可以通过组合这些解决方案。例如，遇到null，直接短路返回，然后之后的代码使用表驱动来区分互斥条件，在达成某个互斥条件的时候，通过校验链来验证嵌套条件等。</li>
</ol>
</blockquote>
<h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型是一个适用于多种类型的函数，其中T为类型变量</p>
<pre><code class="js">function identity&lt;T&gt;(arg: T): T &#123;
    return arg;
&#125;</code></pre>
<p>微前端框架</p>
<p>微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Nginx路由转发</td>
<td>通过Nginx配置反向代理来实现不同路径映射到不同应用，例如<a href="http://www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。">www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。</a></td>
<td>简单，快速，易配置</td>
<td>在切换应用时会触发浏览器刷新，影响体验</td>
</tr>
<tr>
<td>iframe嵌套</td>
<td>父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式</td>
<td>实现简单，子应用之间自带沙箱，天然隔离，互不影响</td>
<td>iframe的样式显示、兼容性等都具有局限性；太过简单而显得low</td>
</tr>
<tr>
<td>Web Components</td>
<td>每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式</td>
<td>每个子应用拥有独立的script和css，也可单独部署</td>
<td>对于历史系统改造成本高，子应用通信较为复杂易踩坑</td>
</tr>
<tr>
<td>组合式应用路由分发</td>
<td>每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制</td>
<td>纯前端改造，体验良好，可无感知切换，子应用相互隔离</td>
<td>需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点</td>
</tr>
</tbody></table>
<p><a href="https://juejin.cn/post/6844904162509979662">参考</a></p>
<h3 id="react-高阶组件"><a href="#react-高阶组件" class="headerlink" title="react 高阶组件"></a>react 高阶组件</h3><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a>是参数为组件，返回值为新组件的函数。</p>
<h3 id="react-错误边界"><a href="#react-错误边界" class="headerlink" title="react 错误边界"></a>react 错误边界</h3><p>错误边界是一种 React 组件，这种组件<strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。</p>
<ul>
<li>React内部其实也是通过 <code>try...catch...</code> 形式是捕获各阶段的异常</li>
<li>但是只在 fiber 的 reconciliation 和 commit 两个阶段的特定几处进行了异常捕获，这也是为什么异常边界只能捕获到子组件在构造函数、render函数以及所有生命周期函数中抛出的异常</li>
</ul>
<p><a href="https://github.com/HuJiaoHJ/blog/issues/12">参考</a></p>
<h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p><a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html"><code>&lt;KeepAlive&gt;</code></a> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p>
<p>其通过在内置组件 render 方法缓存 vnode 和后面渲染的过程中缓存真实 dom 达到缓存组件实例的目的。</p>
<p><a href="https://juejin.cn/post/6844903950886371342#heading-1">参考</a></p>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>TCP 是面向连接，UDP 是无连接的</li>
<li>TCP 提供可靠交付，UDP 尽最大可能交付</li>
<li>TCP 是面向字节流，UDP 是面向报文</li>
<li>TCP 有拥堵控制而UPD没有</li>
</ul>
<p><a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html">参考</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/108822858">TCP 和 UDP 的</a></p>
<h3 id="MVC-和-MVP-以及-MVVM-的区别"><a href="#MVC-和-MVP-以及-MVVM-的区别" class="headerlink" title="MVC 和 MVP 以及 MVVM 的区别"></a><a href="https://draveness.me/mvx/">MVC 和 MVP 以及 MVVM 的区别</a></h3><p>无论是 MVVM 还是 Presentation Model，其中最重要的不是如何同步视图和展示模型/视图模型之间的状态，是使用观察者模式、双向绑定还是其它的机制都不是整个模式中最重要的部分，最为关键的是<strong>展示模型/视图模型创建了一个视图的抽象，将视图中的状态和行为抽离出一个新的抽象</strong>，这才是 MVVM 和 PM 中需要注意的。</p>
<h3 id="什么是突变和纯函数"><a href="#什么是突变和纯函数" class="headerlink" title="什么是突变和纯函数"></a><a href="https://cloud.tencent.com/developer/article/1412040">什么是突变和纯函数</a></h3><h3 id="Promise-和-await-内部的错误处理"><a href="#Promise-和-await-内部的错误处理" class="headerlink" title="Promise 和 await 内部的错误处理"></a>Promise 和 await 内部的错误处理</h3><p> Promise 内部产生错误过程：内部抛出错误 -&gt; Promise 状态变为 reject -&gt;  throw Error 到上层 -&gt; 有 catch 则捕获后处理，并且不再往上    throw -&gt; 无 catch 抛出到上层可以被 unhandledrejection（浏览器环境） 或 uncaughtException（node 环境） 监听捕获 -&gt; window.onerror</p>
<h3 id="怎么处理前端异常"><a href="#怎么处理前端异常" class="headerlink" title="怎么处理前端异常"></a>怎么处理前端异常</h3><p>1.可疑区域增加 <code>Try-Catch</code><br>2.全局监控 <code>JS</code> 异常 <code>window.onerror</code><br>3.全局监控静态资源异常 <code>window.addEventListener</code><br>4.捕获没有 <code>Catch</code> 的 <code>Promise</code> 异常：<code>unhandledrejection</code><br>5.<code>VUE errorHandler</code> 和 <code>React componentDidCatch</code><br>6.监控网页崩溃：<code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code><br>7.跨域 <code>crossOrigin</code> 解决</p>
<p><a href="http://jartto.wang/2018/11/20/js-exception-handling/">参考</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端自测流程</title>
    <url>/2018/12/24/%E5%89%8D%E7%AB%AF%E8%87%AA%E6%B5%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前端自测流程"><a href="#前端自测流程" class="headerlink" title="前端自测流程"></a>前端自测流程</h1><p>由于团队交付测试简单bug太多，为了保证前端页面的质量，建议先进行简单自测，我收集了部分资料，总结了一些前端自测的流程规范，希望能作为大家页面开发完毕后自测的参考。</p>
<p>首先，测试的顺序为：自上向下、从左到右</p>
<ul>
<li>界面测试<ul>
<li>布局是否合理，是否对齐，字体大小是否统一</li>
<li>查看页面的Title是否准确和合理</li>
<li>大小屏幕是否兼容适配</li>
<li>是否有错别字，中英文是否翻译，翻译是否合理、大小写是否有问题</li>
<li>字体图标是否有溢出、隐藏</li>
<li>时间及日期显示格式是否统一</li>
<li>相同含义属性/字段名是否统一</li>
<li>数据精度显示是否统一：如单价0元，应显示为0.00元</li>
</ul>
</li>
<li>主要功能点测试<ul>
<li>搜索测试<ul>
<li>搜索按钮功能是否实现</li>
<li>输入键盘中所有特殊字符，是否报错；特别关注：_ ？ ’ . •\  / – ；空格等特殊字符</li>
<li>搜索表单分页测试，是否数据会切换</li>
<li>是否绑定回车键、Tab键</li>
<li>多条件搜索，要采取组合的方式，每种情况搜索一遍看结果是否符合预期</li>
<li>进行输入域测试，对于手机、邮箱、证件号等的输入是否有长度及类型，是否有必填项的控制</li>
</ul>
</li>
<li>表单测试<ul>
<li>提交、清空、注册、登录或其他功能按钮是否实现</li>
<li>表单提交数据是否与页面数据相同</li>
<li>提交的数据是否能正确保存到后台数据库中，刷新后是否丢失</li>
<li>表单提交，删除，修改后是否有提示信息，提示、警告、或错误说明是否清楚、明了、恰当。</li>
<li>进行输入域测试</li>
</ul>
</li>
<li>url测试<ul>
<li>搜索页面url是否加上搜索参数，刷新页面是否按url中搜索参数搜索</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
  </entry>
</search>
